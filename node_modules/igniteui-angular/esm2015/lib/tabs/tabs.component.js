/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { CommonModule } from '@angular/common';
import { Component, ContentChildren, ElementRef, EventEmitter, forwardRef, HostBinding, Input, NgModule, Output, QueryList, ViewChild, ViewChildren, NgZone } from '@angular/core';
import { IgxBadgeModule } from '../badge/badge.component';
import { IgxRippleModule } from '../directives/ripple/ripple.directive';
import { IgxIconModule } from '../icon/index';
import { IgxTabItemComponent } from './tab-item.component';
import { IgxTabsGroupComponent } from './tabs-group.component';
import { IgxLeftButtonStyleDirective, IgxRightButtonStyleDirective, IgxTabItemTemplateDirective } from './tabs.directives';
import { IgxTabsBase } from './tabs.common';
import ResizeObserver from 'resize-observer-polyfill';
import { PlatformUtil } from '../core/utils';
/** @enum {string} */
const TabsType = {
    FIXED: 'fixed',
    CONTENTFIT: 'contentfit',
};
export { TabsType };
/** @type {?} */
let NEXT_TABS_ID = 0;
export class IgxTabsComponent {
    /**
     * @param {?} _element
     * @param {?} _ngZone
     * @param {?} platformUtil
     */
    constructor(_element, _ngZone, platformUtil) {
        this._element = _element;
        this._ngZone = _ngZone;
        this.platformUtil = platformUtil;
        this._currentTabsId = NEXT_TABS_ID++;
        /**
         * @hidden
         */
        this.selectedIndexChange = new EventEmitter();
        /**
         * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
         * By default the header sizing mode is `contentfit`.
         * ```html
         * <igx-tabs tabsType="fixed">
         *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
         * </igx-tabs>
         * ```
         */
        this.tabsType = 'contentfit';
        /**
         * Sets/gets the `id` of the tabs.
         *
         * \@remarks
         * If not set, the `id` will have value `"igx-tabs-0"`.
         *
         * \@example
         * ```html
         * <igx-tabs id="my-first-tabs"></igx-tabs>
         * ```
         * \@memberof IgxTabsComponent
         */
        this.id = `igx-tabs-${this._currentTabsId}`;
        /**
         * @hidden
         */
        this.class = '';
        /**
         * Emitted when a tab item is deselected.
         * ```html
         * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemDeselected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemDeselected = new EventEmitter();
        /**
         * Emitted when a tab item is selected.
         * ```html
         * <igx-tabs (onTabItemSelected)="itemSelected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemSelected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemSelected = new EventEmitter();
        /**
         * @hidden
         */
        this.offset = 0;
        this._selectedIndex = -1;
    }
    /**
     * An \@Input property that sets the value of the `selectedIndex`.
     * Default value is 0.
     * ```html
     * <igx-tabs selectedIndex="1">
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-tabs [(selectedIndex)]="model.selectedIndex">
     * ```
     * @return {?}
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    /**
     * @param {?} index
     * @return {?}
     */
    set selectedIndex(index) {
        /** @type {?} */
        const newIndex = typeof index !== 'number' ? parseInt(index, 10) : index;
        if (this._selectedIndex !== newIndex) {
            if (this.tabs && this.tabs.length > 0) {
                /** @type {?} */
                const newTab = this.tabs.toArray()[newIndex];
                if (newTab) {
                    this.performSelectionChange(newTab);
                }
            }
            else {
                this._selectedIndex = newIndex;
            }
        }
    }
    /**
     * Provides an observable collection of all `IgxTabItemComponent`s.
     * First try to get them as content children if not available get them as view children.
     * ```typescript
     * const tabItems = this.myTabComponent.tabs;
     * ```
     * @return {?}
     */
    get tabs() {
        if (this.hasContentTabs) {
            return this.contentTabs;
        }
        return this.viewTabs;
    }
    /**
     * @hidden
     * @return {?}
     */
    get hasContentTabs() {
        return (this.contentTabs && this.contentTabs.length > 0);
    }
    /**
     * @hidden
     * @return {?}
     */
    get cssClass() {
        /** @type {?} */
        const defaultStyle = `igx-tabs`;
        /** @type {?} */
        const fixedStyle = `igx-tabs--fixed`;
        /** @type {?} */
        const iconStyle = `igx-tabs--icons`;
        /** @type {?} */
        const iconLabelFoundInGroups = this.groups.find((group) => group.icon != null && group.label != null);
        /** @type {?} */
        const iconLabelFoundInTabs = this.contentTabs.find((tab) => tab.icon != null && tab.label != null);
        /** @type {?} */
        let css;
        switch (TabsType[this.tabsType.toUpperCase()]) {
            case TabsType.FIXED: {
                css = fixedStyle;
                break;
            }
            default: {
                css = defaultStyle;
                break;
            }
        }
        // Layout fix for items with icons
        if (iconLabelFoundInGroups !== undefined || iconLabelFoundInTabs !== undefined) {
            css = `${css} ${iconStyle}`;
        }
        return `${css} ${this.class}`;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    scrollLeft(event) {
        this.scroll(false);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    scrollRight(event) {
        this.scroll(true);
    }
    /**
     * @hidden
     * @param {?} element
     * @param {?} scrollRight
     * @return {?}
     */
    scrollElement(element, scrollRight) {
        /** @type {?} */
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        this.offset = (scrollRight) ? element.offsetWidth + element.offsetLeft - viewPortWidth : element.offsetLeft;
        this.itemsContainer.nativeElement.style.transform = `translate(${-this.offset}px)`;
    }
    /**
     * Gets the selected `IgxTabItemComponent`.
     * ```
     * const selectedItem = this.myTabComponent.selectedTabItem;
     * ```
     * @return {?}
     */
    get selectedTabItem() {
        if (this.tabs && this.selectedIndex !== undefined) {
            return this.tabs.toArray()[this.selectedIndex];
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        if (this._selectedIndex === -1) {
            this.tabs.forEach((t) => {
                if (t.isSelected) {
                    this._selectedIndex = t.index;
                }
            });
        }
        if (!this.hasContentTabs && (this.selectedIndex < 0 || this.selectedIndex >= this.groups.length)) {
            this._selectedIndex = 0;
        }
        if (this.platformUtil.isBrowser) {
            requestAnimationFrame(() => {
                /** @type {?} */
                const newTab = this.tabs.toArray()[this._selectedIndex];
                if (newTab) {
                    this.performSelection(newTab);
                }
                else {
                    this.hideIndicator();
                }
            });
            this._ngZone.runOutsideAngular(() => {
                this._resizeObserver = new ResizeObserver(() => {
                    if (!this.hasContentTabs && this._selectedIndex >= 0 && this._selectedIndex < this.tabs.length) {
                        /** @type {?} */
                        const newTab = this.tabs.toArray()[this._selectedIndex];
                        this.transformContentAnimation(newTab, 0);
                    }
                });
                this._resizeObserver.observe(this.tabsContainer.nativeElement);
            });
        }
        this.setGroupsAttributes();
        this._groupChanges$ = this.groups.changes.subscribe(() => {
            this.setGroupsAttributes();
            this.resetSelectionOnCollectionChanged();
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        if (this._groupChanges$) {
            this._groupChanges$.unsubscribe();
        }
        if (this._resizeObserver) {
            this._ngZone.runOutsideAngular(() => {
                this._resizeObserver.disconnect();
            });
        }
    }
    /**
     * @private
     * @return {?}
     */
    setGroupsAttributes() {
        /** @type {?} */
        const groupsArray = this.groups.toArray();
        for (let index = 0; index < this.groups.length; index++) {
            /** @type {?} */
            const tabsGroup = (/** @type {?} */ (groupsArray[index]));
            tabsGroup.nativeElement.setAttribute('id', this.getTabsGroupId(index));
            tabsGroup.nativeElement.setAttribute('aria-labelledby', this.getTabItemId(index));
        }
    }
    /**
     * @private
     * @return {?}
     */
    resetSelectionOnCollectionChanged() {
        requestAnimationFrame(() => {
            /** @type {?} */
            const currentTab = this.tabs.toArray()[this.selectedIndex];
            if (currentTab) {
                this.performSelectionChange(currentTab);
            }
            else if (this.selectedIndex >= this.tabs.length) {
                this.performSelectionChange(this.tabs.last);
            }
            else {
                this.hideIndicator();
            }
        });
    }
    /**
     * @private
     * @param {?} scrollRight
     * @return {?}
     */
    scroll(scrollRight) {
        /** @type {?} */
        const tabsArray = this.tabs.toArray();
        for (const tab of tabsArray) {
            /** @type {?} */
            const element = tab.nativeTabItem.nativeElement;
            if (scrollRight) {
                if (element.offsetWidth + element.offsetLeft > this.viewPort.nativeElement.offsetWidth + this.offset) {
                    this.scrollElement(element, scrollRight);
                    break;
                }
            }
            else {
                if (element.offsetWidth + element.offsetLeft >= this.offset) {
                    this.scrollElement(element, scrollRight);
                    break;
                }
            }
        }
    }
    /**
     * @hidden
     * @param {?} newTab
     * @return {?}
     */
    performSelectionChange(newTab) {
        /** @type {?} */
        const oldTab = this.selectedTabItem;
        if (oldTab) {
            this.performDeselection(oldTab);
        }
        if (newTab) {
            this.performSelection(newTab);
        }
        else {
            // if there is no new selected tab hide the selection indicator
            this.hideIndicator();
        }
        this.selectedIndexChange.emit(this._selectedIndex);
    }
    /**
     * @private
     * @param {?} oldTab
     * @return {?}
     */
    performDeselection(oldTab) {
        oldTab.setSelectedInternal(false);
        /** @type {?} */
        const oldTabRelatedGroup = this.groups.toArray()[oldTab.index];
        if (oldTabRelatedGroup) {
            oldTabRelatedGroup.setSelectedInternal(false);
        }
        this._selectedIndex = -1;
        this.onTabItemDeselected.emit({ tab: oldTab, group: oldTabRelatedGroup });
    }
    /**
     * @private
     * @param {?} newTab
     * @return {?}
     */
    performSelection(newTab) {
        newTab.setSelectedInternal(true);
        this._selectedIndex = newTab.index;
        /** @type {?} */
        let newTabRelatedGroup = null;
        if (!this.hasContentTabs && this.groups) {
            newTabRelatedGroup = this.groups.toArray()[newTab.index];
            if (newTabRelatedGroup) {
                newTabRelatedGroup.setSelectedInternal(true);
            }
        }
        this.onTabItemSelected.emit({ tab: newTab, group: newTabRelatedGroup });
        requestAnimationFrame(() => {
            // bring the new selected tab into view if it is not
            this.bringNewTabIntoView(newTab);
            // animate the new selection indicator
            this.transformIndicatorAnimation(newTab.nativeTabItem.nativeElement);
            // animate the new tab's group content
            if (!this.hasContentTabs) {
                this.transformContentAnimation(newTab, 0.2);
            }
        });
    }
    /**
     * @private
     * @param {?} newTab
     * @return {?}
     */
    bringNewTabIntoView(newTab) {
        /** @type {?} */
        const tabNativeElement = newTab.nativeTabItem.nativeElement;
        // Scroll left if there is need
        if (tabNativeElement.offsetLeft < this.offset) {
            this.scrollElement(tabNativeElement, false);
        }
        // Scroll right if there is need
        /** @type {?} */
        const viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
        /** @type {?} */
        const delta = (tabNativeElement.offsetLeft + tabNativeElement.offsetWidth) - (viewPortOffsetWidth + this.offset);
        // Fix for IE 11, a difference is accumulated from the widths calculations
        if (delta > 1) {
            this.scrollElement(tabNativeElement, true);
        }
    }
    /**
     * @hidden
     * @param {?} index
     * @return {?}
     */
    getTabItemId(index) {
        return `igx-tab-item-${this._currentTabsId}-${index}`;
    }
    /**
     * @hidden
     * @param {?} index
     * @return {?}
     */
    getTabsGroupId(index) {
        return `igx-tabs-group-${this._currentTabsId}-${index}`;
    }
    /**
     * @hidden
     * @param {?} tab
     * @param {?} duration
     * @return {?}
     */
    // animation for the new panel/group (not needed for tab only mode)
    transformContentAnimation(tab, duration) {
        /** @type {?} */
        const contentOffset = this.tabsContainer.nativeElement.offsetWidth * tab.index;
        this.contentsContainer.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
        this.contentsContainer.nativeElement.style.transform = `translate(${-contentOffset}px)`;
    }
    /**
     * @hidden
     * @param {?} element
     * @param {?=} duration
     * @return {?}
     */
    transformIndicatorAnimation(element, duration = 0.3) {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'visible';
            this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
            this.selectedIndicator.nativeElement.style.width = `${element.offsetWidth}px`;
            this.selectedIndicator.nativeElement.style.transform = `translate(${element.offsetLeft}px)`;
        }
    }
    /**
     * @return {?}
     */
    hideIndicator() {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'hidden';
        }
    }
}
IgxTabsComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-tabs',
                template: "<!-- TODO Remove tab container from here -->\n<div #tabsContainer>\n    <div class=\"igx-tabs__header\" #headerContainer>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollLeft($event)\" igxLeftButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_before</igx-icon>\n        </button>\n        <div class=\"igx-tabs__header-wrapper-fixed\" #viewPort>\n            <div #itemsContainer class=\"igx-tabs__header-wrapper-fluid\">\n                <ng-container *ngIf=\"!hasContentTabs\">\n                    <igx-tab-item igxRipple\n                        *ngFor=\"let group of groups; let i = index\"\n                        [relatedGroup]=\"group\"\n                        [autoGenerated]=\"true\"\n                        [id]=\"getTabItemId(i)\"\n                        [attr.aria-controls]=\"getTabsGroupId(i)\">\n                    </igx-tab-item>\n                </ng-container>\n                <ng-content select=\"igx-tab-item\"></ng-content>\n                <div #selectedIndicator *ngIf=\"groups.length > 0 || contentTabs.length > 0\" class=\"igx-tabs__header-menu-item-indicator\"></div>\n            </div>\n        </div>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollRight($event)\" igxRightButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_next</igx-icon>\n        </button>\n    </div>\n    <div class=\"igx-tabs__content-fixed\">\n        <div #contentsContainer class=\"igx-tabs__content-fluid\">\n            <ng-content></ng-content>\n        </div>\n    </div>\n</div>\n",
                providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }]
            }] }
];
/** @nocollapse */
IgxTabsComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: PlatformUtil }
];
IgxTabsComponent.propDecorators = {
    groups: [{ type: ContentChildren, args: [forwardRef(() => IgxTabsGroupComponent),] }],
    contentTabs: [{ type: ContentChildren, args: [forwardRef(() => IgxTabItemComponent),] }],
    selectedIndex: [{ type: Input }],
    selectedIndexChange: [{ type: Output }],
    tabsType: [{ type: Input, args: ['tabsType',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    class: [{ type: Input }],
    onTabItemDeselected: [{ type: Output }],
    onTabItemSelected: [{ type: Output }],
    contentsContainer: [{ type: ViewChild, args: ['contentsContainer', { static: true },] }],
    headerContainer: [{ type: ViewChild, args: ['headerContainer', { static: true },] }],
    itemsContainer: [{ type: ViewChild, args: ['itemsContainer', { static: true },] }],
    selectedIndicator: [{ type: ViewChild, args: ['selectedIndicator', { static: false },] }],
    tabsContainer: [{ type: ViewChild, args: ['tabsContainer', { static: true },] }],
    viewPort: [{ type: ViewChild, args: ['viewPort', { static: true },] }],
    viewTabs: [{ type: ViewChildren, args: [forwardRef(() => IgxTabItemComponent),] }],
    cssClass: [{ type: HostBinding, args: ['attr.class',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype._currentTabsId;
    /**
     * Provides an observable collection of all `IgxTabsGroupComponent`s.
     * ```typescript
     * const groupItems = this.myTabComponent.groups;
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.groups;
    /**
     * Provides an observable collection of all `IgxTabItemComponent`s defined in the page.
     * ```typescript
     * const tabItems = this.myTabComponent.contentTabs;
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.contentTabs;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.selectedIndexChange;
    /**
     * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
     * By default the header sizing mode is `contentfit`.
     * ```html
     * <igx-tabs tabsType="fixed">
     *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
     * </igx-tabs>
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.tabsType;
    /**
     * Sets/gets the `id` of the tabs.
     *
     * \@remarks
     * If not set, the `id` will have value `"igx-tabs-0"`.
     *
     * \@example
     * ```html
     * <igx-tabs id="my-first-tabs"></igx-tabs>
     * ```
     * \@memberof IgxTabsComponent
     * @type {?}
     */
    IgxTabsComponent.prototype.id;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.class;
    /**
     * Emitted when a tab item is deselected.
     * ```html
     * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
     *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
     *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
     * </igx-tabs>
     * ```
     * ```typescript
     * itemDeselected(e){
     *      const tabGroup = e.group;
     *      const tabItem = e.tab;
     * }
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.onTabItemDeselected;
    /**
     * Emitted when a tab item is selected.
     * ```html
     * <igx-tabs (onTabItemSelected)="itemSelected($event)">
     *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
     *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
     * </igx-tabs>
     * ```
     * ```typescript
     * itemSelected(e){
     *      const tabGroup = e.group;
     *      const tabItem = e.tab;
     * }
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.onTabItemSelected;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.contentsContainer;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.headerContainer;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.itemsContainer;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.selectedIndicator;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.tabsContainer;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.viewPort;
    /**
     * Provides an observable collection of all `IgxTabItemComponent`s.
     * ```typescript
     * const tabItems = this.myTabComponent.viewTabs;
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.viewTabs;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.calculatedWidth;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.visibleItemsWidth;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.offset;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype._groupChanges$;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype._selectedIndex;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype._resizeObserver;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype._element;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype.platformUtil;
}
/**
 * @hidden
 */
export class IgxTabsModule {
}
IgxTabsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxTabsComponent,
                    IgxTabsGroupComponent,
                    IgxTabItemComponent,
                    IgxTabItemTemplateDirective,
                    IgxRightButtonStyleDirective,
                    IgxLeftButtonStyleDirective],
                exports: [IgxTabsComponent,
                    IgxTabsGroupComponent,
                    IgxTabItemComponent,
                    IgxTabItemTemplateDirective,
                    IgxRightButtonStyleDirective,
                    IgxLeftButtonStyleDirective],
                imports: [CommonModule, IgxBadgeModule, IgxIconModule, IgxRippleModule]
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFicy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL3RhYnMvdGFicy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBRUgsU0FBUyxFQUNULGVBQWUsRUFDZixVQUFVLEVBQ1YsWUFBWSxFQUNaLFVBQVUsRUFDVixXQUFXLEVBQ1gsS0FBSyxFQUNMLFFBQVEsRUFDUixNQUFNLEVBQ04sU0FBUyxFQUNULFNBQVMsRUFDVCxZQUFZLEVBRVosTUFBTSxFQUNULE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sdUNBQXVDLENBQUM7QUFDeEUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM5QyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMzRCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUMvRCxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsNEJBQTRCLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUMzSCxPQUFPLEVBQUUsV0FBVyxFQUFrQixNQUFNLGVBQWUsQ0FBQztBQUM1RCxPQUFPLGNBQWMsTUFBTSwwQkFBMEIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDOzs7SUFHekMsT0FBUSxPQUFPO0lBQ2YsWUFBYSxZQUFZOzs7O0lBR3pCLFlBQVksR0FBRyxDQUFDO0FBUXBCLE1BQU0sT0FBTyxnQkFBZ0I7Ozs7OztJQXVSekIsWUFBb0IsUUFBb0IsRUFBVSxPQUFlLEVBQVUsWUFBMEI7UUFBakYsYUFBUSxHQUFSLFFBQVEsQ0FB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LDJCQUEyQjtvQkFDM0IsNEJBQTRCO29CQUM1QiwyQkFBMkIsQ0FBQztnQkFDaEMsT0FBTyxFQUFFLENBQUMsZ0JBQWdCO29CQUN0QixxQkFBcUI7b0JBQ3JCLG1CQUFtQjtvQkFDbkIsMkJBQTJCO29CQUMzQiw0QkFBNEI7b0JBQzVCLDJCQUEyQixDQUFDO2dCQUNoQyxPQUFPLEVBQUUsQ0FBQyxZQUFZLEVBQUUsY0FBYyxFQUFFLGFBQWEsRUFBRSxlQUFlLENBQUM7YUFDMUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGRyZW4sXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBIb3N0QmluZGluZyxcbiAgICBJbnB1dCxcbiAgICBOZ01vZHVsZSxcbiAgICBPdXRwdXQsXG4gICAgUXVlcnlMaXN0LFxuICAgIFZpZXdDaGlsZCxcbiAgICBWaWV3Q2hpbGRyZW4sXG4gICAgT25EZXN0cm95LFxuICAgIE5nWm9uZVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSWd4QmFkZ2VNb2R1bGUgfSBmcm9tICcuLi9iYWRnZS9iYWRnZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4UmlwcGxlTW9kdWxlIH0gZnJvbSAnLi4vZGlyZWN0aXZlcy9yaXBwbGUvcmlwcGxlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hJY29uTW9kdWxlIH0gZnJvbSAnLi4vaWNvbi9pbmRleCc7XG5pbXBvcnQgeyBJZ3hUYWJJdGVtQ29tcG9uZW50IH0gZnJvbSAnLi90YWItaXRlbS5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4VGFic0dyb3VwQ29tcG9uZW50IH0gZnJvbSAnLi90YWJzLWdyb3VwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hMZWZ0QnV0dG9uU3R5bGVEaXJlY3RpdmUsIElneFJpZ2h0QnV0dG9uU3R5bGVEaXJlY3RpdmUsIElneFRhYkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSB9IGZyb20gJy4vdGFicy5kaXJlY3RpdmVzJztcbmltcG9ydCB7IElneFRhYnNCYXNlLCBJZ3hUYWJJdGVtQmFzZSB9IGZyb20gJy4vdGFicy5jb21tb24nO1xuaW1wb3J0IFJlc2l6ZU9ic2VydmVyIGZyb20gJ3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbCc7XG5pbXBvcnQgeyBQbGF0Zm9ybVV0aWwgfSBmcm9tICcuLi9jb3JlL3V0aWxzJztcblxuZXhwb3J0IGVudW0gVGFic1R5cGUge1xuICAgIEZJWEVEID0gJ2ZpeGVkJyxcbiAgICBDT05URU5URklUID0gJ2NvbnRlbnRmaXQnXG59XG5cbmxldCBORVhUX1RBQlNfSUQgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC10YWJzJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RhYnMuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogSWd4VGFic0Jhc2UsIHVzZUV4aXN0aW5nOiBJZ3hUYWJzQ29tcG9uZW50IH1dXG59KVxuXG5leHBvcnQgY2xhc3MgSWd4VGFic0NvbXBvbmVudCBpbXBsZW1lbnRzIElneFRhYnNCYXNlLCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgX2N1cnJlbnRUYWJzSWQgPSBORVhUX1RBQlNfSUQrKztcblxuICAgIC8qKlxuICAgICogUHJvdmlkZXMgYW4gb2JzZXJ2YWJsZSBjb2xsZWN0aW9uIG9mIGFsbCBgSWd4VGFic0dyb3VwQ29tcG9uZW50YHMuXG4gICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgKiBjb25zdCBncm91cEl0ZW1zID0gdGhpcy5teVRhYkNvbXBvbmVudC5ncm91cHM7XG4gICAgKiBgYGBcbiAgICAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oZm9yd2FyZFJlZigoKSA9PiBJZ3hUYWJzR3JvdXBDb21wb25lbnQpKVxuICAgIHB1YmxpYyBncm91cHM6IFF1ZXJ5TGlzdDxJZ3hUYWJzR3JvdXBDb21wb25lbnQ+O1xuXG4gICAgLyoqXG4gICAgKiBQcm92aWRlcyBhbiBvYnNlcnZhYmxlIGNvbGxlY3Rpb24gb2YgYWxsIGBJZ3hUYWJJdGVtQ29tcG9uZW50YHMgZGVmaW5lZCBpbiB0aGUgcGFnZS5cbiAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAqIGNvbnN0IHRhYkl0ZW1zID0gdGhpcy5teVRhYkNvbXBvbmVudC5jb250ZW50VGFicztcbiAgICAqIGBgYFxuICAgICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihmb3J3YXJkUmVmKCgpID0+IElneFRhYkl0ZW1Db21wb25lbnQpKVxuICAgIHB1YmxpYyBjb250ZW50VGFiczogUXVlcnlMaXN0PElneFRhYkl0ZW1Db21wb25lbnQ+O1xuXG4gICAgLyoqXG4gICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYHNlbGVjdGVkSW5kZXhgLlxuICAgICogRGVmYXVsdCB2YWx1ZSBpcyAwLlxuICAgICogYGBgaHRtbFxuICAgICogPGlneC10YWJzIHNlbGVjdGVkSW5kZXg9XCIxXCI+XG4gICAgKiBgYGBcbiAgICAqXG4gICAgKiBUd28td2F5IGRhdGEgYmluZGluZy5cbiAgICAqIGBgYGh0bWxcbiAgICAqIDxpZ3gtdGFicyBbKHNlbGVjdGVkSW5kZXgpXT1cIm1vZGVsLnNlbGVjdGVkSW5kZXhcIj5cbiAgICAqIGBgYFxuICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHNlbGVjdGVkSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkSW5kZXg7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBzZWxlY3RlZEluZGV4KGluZGV4OiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0eXBlb2YgaW5kZXggIT09ICdudW1iZXInID8gcGFyc2VJbnQoaW5kZXgsIDEwKSA6IGluZGV4O1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRJbmRleCAhPT0gbmV3SW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhYnMgJiYgdGhpcy50YWJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUYWIgPSB0aGlzLnRhYnMudG9BcnJheSgpW25ld0luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAobmV3VGFiKSB7XG4gICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtU2VsZWN0aW9uQ2hhbmdlKG5ld1RhYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gbmV3SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgc2VsZWN0ZWRJbmRleENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgdGFiIGhlYWRlciBzaXppbmcgbW9kZS4gWW91IGNhbiBjaG9vc2UgYmV0d2VlbiBgY29udGVudGZpdGAgb3IgYGZpeGVkYC5cbiAgICAgKiBCeSBkZWZhdWx0IHRoZSBoZWFkZXIgc2l6aW5nIG1vZGUgaXMgYGNvbnRlbnRmaXRgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRhYnMgdGFic1R5cGU9XCJmaXhlZFwiPlxuICAgICAqICAgICA8aWd4LXRhYnMtZ3JvdXAgbGFiZWw9XCJIT01FXCI+SG9tZTwvaWd4LXRhYnMtZ3JvdXA+XG4gICAgICogPC9pZ3gtdGFicz5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoJ3RhYnNUeXBlJylcbiAgICBwdWJsaWMgdGFic1R5cGU6IHN0cmluZyB8IFRhYnNUeXBlID0gJ2NvbnRlbnRmaXQnO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBgaWRgIG9mIHRoZSB0YWJzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiBub3Qgc2V0LCB0aGUgYGlkYCB3aWxsIGhhdmUgdmFsdWUgYFwiaWd4LXRhYnMtMFwiYC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdGFicyBpZD1cIm15LWZpcnN0LXRhYnNcIj48L2lneC10YWJzPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUYWJzQ29tcG9uZW50XG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZCA9IGBpZ3gtdGFicy0ke3RoaXMuX2N1cnJlbnRUYWJzSWR9YDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBjbGFzcyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIGEgdGFiIGl0ZW0gaXMgZGVzZWxlY3RlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10YWJzIChvblRhYkl0ZW1EZXNlbGVjdGVkKT1cIml0ZW1EZXNlbGVjdGVkKCRldmVudClcIj5cbiAgICAgKiAgICAgIDxpZ3gtdGFicy1ncm91cCBsYWJlbD1cIlRhYiAxXCI+VGhpcyBpcyBUYWIgMSBjb250ZW50LjwvaWd4LXRhYnMtZ3JvdXA+XG4gICAgICogICAgICA8aWd4LXRhYnMtZ3JvdXAgbGFiZWw9XCJUYWIgMlwiPlRoaXMgaXMgVGFiIDIgY29udGVudC48L2lneC10YWJzLWdyb3VwPlxuICAgICAqIDwvaWd4LXRhYnM+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGl0ZW1EZXNlbGVjdGVkKGUpe1xuICAgICAqICAgICAgY29uc3QgdGFiR3JvdXAgPSBlLmdyb3VwO1xuICAgICAqICAgICAgY29uc3QgdGFiSXRlbSA9IGUudGFiO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25UYWJJdGVtRGVzZWxlY3RlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICogRW1pdHRlZCB3aGVuIGEgdGFiIGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAgKiBgYGBodG1sXG4gICAgKiA8aWd4LXRhYnMgKG9uVGFiSXRlbVNlbGVjdGVkKT1cIml0ZW1TZWxlY3RlZCgkZXZlbnQpXCI+XG4gICAgKiAgICAgIDxpZ3gtdGFicy1ncm91cCBsYWJlbD1cIlRhYiAxXCI+VGhpcyBpcyBUYWIgMSBjb250ZW50LjwvaWd4LXRhYnMtZ3JvdXA+XG4gICAgKiAgICAgIDxpZ3gtdGFicy1ncm91cCBsYWJlbD1cIlRhYiAyXCI+VGhpcyBpcyBUYWIgMiBjb250ZW50LjwvaWd4LXRhYnMtZ3JvdXA+XG4gICAgKiA8L2lneC10YWJzPlxuICAgICogYGBgXG4gICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgKiBpdGVtU2VsZWN0ZWQoZSl7XG4gICAgKiAgICAgIGNvbnN0IHRhYkdyb3VwID0gZS5ncm91cDtcbiAgICAqICAgICAgY29uc3QgdGFiSXRlbSA9IGUudGFiO1xuICAgICogfVxuICAgICogYGBgXG4gICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25UYWJJdGVtU2VsZWN0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnY29udGVudHNDb250YWluZXInLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHB1YmxpYyBjb250ZW50c0NvbnRhaW5lcjogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdoZWFkZXJDb250YWluZXInLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHB1YmxpYyBoZWFkZXJDb250YWluZXI6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnaXRlbXNDb250YWluZXInLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHB1YmxpYyBpdGVtc0NvbnRhaW5lcjogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdzZWxlY3RlZEluZGljYXRvcicsIHsgc3RhdGljOiBmYWxzZSB9KVxuICAgIHB1YmxpYyBzZWxlY3RlZEluZGljYXRvcjogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICovXG4gICAgQFZpZXdDaGlsZCgndGFic0NvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIHRhYnNDb250YWluZXI6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgndmlld1BvcnQnLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHB1YmxpYyB2aWV3UG9ydDogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGFuIG9ic2VydmFibGUgY29sbGVjdGlvbiBvZiBhbGwgYElneFRhYkl0ZW1Db21wb25lbnRgcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgdGFiSXRlbXMgPSB0aGlzLm15VGFiQ29tcG9uZW50LnZpZXdUYWJzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGRyZW4oZm9yd2FyZFJlZigoKSA9PiBJZ3hUYWJJdGVtQ29tcG9uZW50KSlcbiAgICBwdWJsaWMgdmlld1RhYnM6IFF1ZXJ5TGlzdDxJZ3hUYWJJdGVtQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGFuIG9ic2VydmFibGUgY29sbGVjdGlvbiBvZiBhbGwgYElneFRhYkl0ZW1Db21wb25lbnRgcy5cbiAgICAgKiBGaXJzdCB0cnkgdG8gZ2V0IHRoZW0gYXMgY29udGVudCBjaGlsZHJlbiBpZiBub3QgYXZhaWxhYmxlIGdldCB0aGVtIGFzIHZpZXcgY2hpbGRyZW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHRhYkl0ZW1zID0gdGhpcy5teVRhYkNvbXBvbmVudC50YWJzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdGFicygpOiBRdWVyeUxpc3Q8SWd4VGFiSXRlbUNvbXBvbmVudD4ge1xuICAgICAgICBpZiAodGhpcy5oYXNDb250ZW50VGFicykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFRhYnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1RhYnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBoYXNDb250ZW50VGFicygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNvbnRlbnRUYWJzICYmIHRoaXMuY29udGVudFRhYnMubGVuZ3RoID4gMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBjYWxjdWxhdGVkV2lkdGg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgdmlzaWJsZUl0ZW1zV2lkdGg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb2Zmc2V0ID0gMDtcblxuICAgIHByaXZhdGUgX2dyb3VwQ2hhbmdlcyQ6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF9zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgcHJpdmF0ZSBfcmVzaXplT2JzZXJ2ZXI6IFJlc2l6ZU9ic2VydmVyO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5jbGFzcycpXG4gICAgcHVibGljIGdldCBjc3NDbGFzcygpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFN0eWxlID0gYGlneC10YWJzYDtcbiAgICAgICAgY29uc3QgZml4ZWRTdHlsZSA9IGBpZ3gtdGFicy0tZml4ZWRgO1xuICAgICAgICBjb25zdCBpY29uU3R5bGUgPSBgaWd4LXRhYnMtLWljb25zYDtcbiAgICAgICAgY29uc3QgaWNvbkxhYmVsRm91bmRJbkdyb3VwcyA9IHRoaXMuZ3JvdXBzLmZpbmQoKGdyb3VwKSA9PiBncm91cC5pY29uICE9IG51bGwgJiYgZ3JvdXAubGFiZWwgIT0gbnVsbCk7XG4gICAgICAgIGNvbnN0IGljb25MYWJlbEZvdW5kSW5UYWJzID0gdGhpcy5jb250ZW50VGFicy5maW5kKCh0YWIpID0+IHRhYi5pY29uICE9IG51bGwgJiYgdGFiLmxhYmVsICE9IG51bGwpO1xuICAgICAgICBsZXQgY3NzO1xuICAgICAgICBzd2l0Y2ggKFRhYnNUeXBlW3RoaXMudGFic1R5cGUudG9VcHBlckNhc2UoKV0pIHtcbiAgICAgICAgICAgIGNhc2UgVGFic1R5cGUuRklYRUQ6IHtcbiAgICAgICAgICAgICAgICBjc3MgPSBmaXhlZFN0eWxlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNzcyA9IGRlZmF1bHRTdHlsZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExheW91dCBmaXggZm9yIGl0ZW1zIHdpdGggaWNvbnNcbiAgICAgICAgaWYgKGljb25MYWJlbEZvdW5kSW5Hcm91cHMgIT09IHVuZGVmaW5lZCB8fCBpY29uTGFiZWxGb3VuZEluVGFicyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjc3MgPSBgJHtjc3N9ICR7aWNvblN0eWxlfWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYCR7Y3NzfSAke3RoaXMuY2xhc3N9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbExlZnQoZXZlbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zY3JvbGwoZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2Nyb2xsUmlnaHQoZXZlbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zY3JvbGwodHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxFbGVtZW50KGVsZW1lbnQ6IGFueSwgc2Nyb2xsUmlnaHQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgdmlld1BvcnRXaWR0aCA9IHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgICAgICB0aGlzLm9mZnNldCA9IChzY3JvbGxSaWdodCkgPyBlbGVtZW50Lm9mZnNldFdpZHRoICsgZWxlbWVudC5vZmZzZXRMZWZ0IC0gdmlld1BvcnRXaWR0aCA6IGVsZW1lbnQub2Zmc2V0TGVmdDtcbiAgICAgICAgdGhpcy5pdGVtc0NvbnRhaW5lci5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHstdGhpcy5vZmZzZXR9cHgpYDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzZWxlY3RlZCBgSWd4VGFiSXRlbUNvbXBvbmVudGAuXG4gICAgICogYGBgXG4gICAgICogY29uc3Qgc2VsZWN0ZWRJdGVtID0gdGhpcy5teVRhYkNvbXBvbmVudC5zZWxlY3RlZFRhYkl0ZW07XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkVGFiSXRlbSgpOiBJZ3hUYWJJdGVtQ29tcG9uZW50IHtcbiAgICAgICAgaWYgKHRoaXMudGFicyAmJiB0aGlzLnNlbGVjdGVkSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFicy50b0FycmF5KClbdGhpcy5zZWxlY3RlZEluZGV4XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnQ6IEVsZW1lbnRSZWYsIHByaXZhdGUgX25nWm9uZTogTmdab25lLCBwcml2YXRlIHBsYXRmb3JtVXRpbDogUGxhdGZvcm1VdGlsKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMudGFicy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHQuaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gdC5pbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5oYXNDb250ZW50VGFicyAmJiAodGhpcy5zZWxlY3RlZEluZGV4IDwgMCB8fCB0aGlzLnNlbGVjdGVkSW5kZXggPj0gdGhpcy5ncm91cHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybVV0aWwuaXNCcm93c2VyKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RhYiA9IHRoaXMudGFicy50b0FycmF5KClbdGhpcy5fc2VsZWN0ZWRJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RhYikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1TZWxlY3Rpb24obmV3VGFiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVJbmRpY2F0b3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzQ29udGVudFRhYnMgJiYgdGhpcy5fc2VsZWN0ZWRJbmRleCA+PSAwICYmIHRoaXMuX3NlbGVjdGVkSW5kZXggPCB0aGlzLnRhYnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUYWIgPSB0aGlzLnRhYnMudG9BcnJheSgpW3RoaXMuX3NlbGVjdGVkSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1Db250ZW50QW5pbWF0aW9uKG5ld1RhYiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy50YWJzQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEdyb3Vwc0F0dHJpYnV0ZXMoKTtcbiAgICAgICAgdGhpcy5fZ3JvdXBDaGFuZ2VzJCA9IHRoaXMuZ3JvdXBzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0R3JvdXBzQXR0cmlidXRlcygpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvbk9uQ29sbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2dyb3VwQ2hhbmdlcyQpIHtcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwQ2hhbmdlcyQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNldEdyb3Vwc0F0dHJpYnV0ZXMoKSB7XG4gICAgICAgIGNvbnN0IGdyb3Vwc0FycmF5ID0gdGhpcy5ncm91cHMudG9BcnJheSgpO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5ncm91cHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJzR3JvdXAgPSBncm91cHNBcnJheVtpbmRleF0gYXMgSWd4VGFic0dyb3VwQ29tcG9uZW50O1xuICAgICAgICAgICAgdGFic0dyb3VwLm5hdGl2ZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuZ2V0VGFic0dyb3VwSWQoaW5kZXgpKTtcbiAgICAgICAgICAgIHRhYnNHcm91cC5uYXRpdmVFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5JywgdGhpcy5nZXRUYWJJdGVtSWQoaW5kZXgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcmVzZXRTZWxlY3Rpb25PbkNvbGxlY3Rpb25DaGFuZ2VkKCk6IHZvaWQge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRhYiA9IHRoaXMudGFicy50b0FycmF5KClbdGhpcy5zZWxlY3RlZEluZGV4XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGFiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtU2VsZWN0aW9uQ2hhbmdlKGN1cnJlbnRUYWIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPj0gdGhpcy50YWJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybVNlbGVjdGlvbkNoYW5nZSh0aGlzLnRhYnMubGFzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUluZGljYXRvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNjcm9sbChzY3JvbGxSaWdodDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBjb25zdCB0YWJzQXJyYXkgPSB0aGlzLnRhYnMudG9BcnJheSgpO1xuICAgICAgICBmb3IgKGNvbnN0IHRhYiBvZiB0YWJzQXJyYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0YWIubmF0aXZlVGFiSXRlbS5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHNjcm9sbFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0V2lkdGggKyBlbGVtZW50Lm9mZnNldExlZnQgPiB0aGlzLnZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggKyB0aGlzLm9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQoZWxlbWVudCwgc2Nyb2xsUmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm9mZnNldFdpZHRoICsgZWxlbWVudC5vZmZzZXRMZWZ0ID49IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudChlbGVtZW50LCBzY3JvbGxSaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgcGVyZm9ybVNlbGVjdGlvbkNoYW5nZShuZXdUYWI6IElneFRhYkl0ZW1CYXNlKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG9sZFRhYiA9IHRoaXMuc2VsZWN0ZWRUYWJJdGVtO1xuICAgICAgICBpZiAob2xkVGFiKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1EZXNlbGVjdGlvbihvbGRUYWIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUYWIpIHtcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybVNlbGVjdGlvbihuZXdUYWIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gbmV3IHNlbGVjdGVkIHRhYiBoaWRlIHRoZSBzZWxlY3Rpb24gaW5kaWNhdG9yXG4gICAgICAgICAgICB0aGlzLmhpZGVJbmRpY2F0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXhDaGFuZ2UuZW1pdCh0aGlzLl9zZWxlY3RlZEluZGV4KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBlcmZvcm1EZXNlbGVjdGlvbihvbGRUYWI6IElneFRhYkl0ZW1CYXNlKTogdm9pZCB7XG4gICAgICAgIG9sZFRhYi5zZXRTZWxlY3RlZEludGVybmFsKGZhbHNlKTtcbiAgICAgICAgY29uc3Qgb2xkVGFiUmVsYXRlZEdyb3VwID0gdGhpcy5ncm91cHMudG9BcnJheSgpW29sZFRhYi5pbmRleF07XG4gICAgICAgIGlmIChvbGRUYWJSZWxhdGVkR3JvdXApIHtcbiAgICAgICAgICAgIG9sZFRhYlJlbGF0ZWRHcm91cC5zZXRTZWxlY3RlZEludGVybmFsKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMub25UYWJJdGVtRGVzZWxlY3RlZC5lbWl0KHsgdGFiOiBvbGRUYWIsIGdyb3VwOiBvbGRUYWJSZWxhdGVkR3JvdXAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwZXJmb3JtU2VsZWN0aW9uKG5ld1RhYjogSWd4VGFiSXRlbUJhc2UpOiB2b2lkIHtcbiAgICAgICAgbmV3VGFiLnNldFNlbGVjdGVkSW50ZXJuYWwodHJ1ZSk7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkSW5kZXggPSBuZXdUYWIuaW5kZXg7XG5cbiAgICAgICAgbGV0IG5ld1RhYlJlbGF0ZWRHcm91cCA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5oYXNDb250ZW50VGFicyAmJiB0aGlzLmdyb3Vwcykge1xuICAgICAgICAgICAgbmV3VGFiUmVsYXRlZEdyb3VwID0gdGhpcy5ncm91cHMudG9BcnJheSgpW25ld1RhYi5pbmRleF07XG4gICAgICAgICAgICBpZiAobmV3VGFiUmVsYXRlZEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgbmV3VGFiUmVsYXRlZEdyb3VwLnNldFNlbGVjdGVkSW50ZXJuYWwodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uVGFiSXRlbVNlbGVjdGVkLmVtaXQoeyB0YWI6IG5ld1RhYiwgZ3JvdXA6IG5ld1RhYlJlbGF0ZWRHcm91cCB9KTtcblxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gYnJpbmcgdGhlIG5ldyBzZWxlY3RlZCB0YWIgaW50byB2aWV3IGlmIGl0IGlzIG5vdFxuICAgICAgICAgICAgdGhpcy5icmluZ05ld1RhYkludG9WaWV3KG5ld1RhYik7XG4gICAgICAgICAgICAvLyBhbmltYXRlIHRoZSBuZXcgc2VsZWN0aW9uIGluZGljYXRvclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1JbmRpY2F0b3JBbmltYXRpb24obmV3VGFiLm5hdGl2ZVRhYkl0ZW0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAvLyBhbmltYXRlIHRoZSBuZXcgdGFiJ3MgZ3JvdXAgY29udGVudFxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0NvbnRlbnRUYWJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1Db250ZW50QW5pbWF0aW9uKG5ld1RhYiwgMC4yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBicmluZ05ld1RhYkludG9WaWV3KG5ld1RhYjogSWd4VGFiSXRlbUJhc2UpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdGFiTmF0aXZlRWxlbWVudCA9IG5ld1RhYi5uYXRpdmVUYWJJdGVtLm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgLy8gU2Nyb2xsIGxlZnQgaWYgdGhlcmUgaXMgbmVlZFxuICAgICAgICBpZiAodGFiTmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0IDwgdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCh0YWJOYXRpdmVFbGVtZW50LCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTY3JvbGwgcmlnaHQgaWYgdGhlcmUgaXMgbmVlZFxuICAgICAgICBjb25zdCB2aWV3UG9ydE9mZnNldFdpZHRoID0gdGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBjb25zdCBkZWx0YSA9ICh0YWJOYXRpdmVFbGVtZW50Lm9mZnNldExlZnQgKyB0YWJOYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoKSAtICh2aWV3UG9ydE9mZnNldFdpZHRoICsgdGhpcy5vZmZzZXQpO1xuXG4gICAgICAgIC8vIEZpeCBmb3IgSUUgMTEsIGEgZGlmZmVyZW5jZSBpcyBhY2N1bXVsYXRlZCBmcm9tIHRoZSB3aWR0aHMgY2FsY3VsYXRpb25zXG4gICAgICAgIGlmIChkZWx0YSA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCh0YWJOYXRpdmVFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0VGFiSXRlbUlkKGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYGlneC10YWItaXRlbS0ke3RoaXMuX2N1cnJlbnRUYWJzSWR9LSR7aW5kZXh9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldFRhYnNHcm91cElkKGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYGlneC10YWJzLWdyb3VwLSR7dGhpcy5fY3VycmVudFRhYnNJZH0tJHtpbmRleH1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICAvLyBhbmltYXRpb24gZm9yIHRoZSBuZXcgcGFuZWwvZ3JvdXAgKG5vdCBuZWVkZWQgZm9yIHRhYiBvbmx5IG1vZGUpXG4gICAgcHVibGljIHRyYW5zZm9ybUNvbnRlbnRBbmltYXRpb24odGFiOiBJZ3hUYWJJdGVtQmFzZSwgZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBjb250ZW50T2Zmc2V0ID0gdGhpcy50YWJzQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggKiB0YWIuaW5kZXg7XG4gICAgICAgIHRoaXMuY29udGVudHNDb250YWluZXIubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiA+IDAgPyBgJHtkdXJhdGlvbn1zYCA6ICdpbml0aWFsJztcbiAgICAgICAgdGhpcy5jb250ZW50c0NvbnRhaW5lci5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHstY29udGVudE9mZnNldH1weClgO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgdHJhbnNmb3JtSW5kaWNhdG9yQW5pbWF0aW9uKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBkdXJhdGlvbiA9IDAuMyk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGljYXRvcikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljYXRvci5uYXRpdmVFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gPiAwID8gYCR7ZHVyYXRpb259c2AgOiAnaW5pdGlhbCc7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHtlbGVtZW50Lm9mZnNldFdpZHRofXB4YDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZWxlbWVudC5vZmZzZXRMZWZ0fXB4KWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgaGlkZUluZGljYXRvcigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbSWd4VGFic0NvbXBvbmVudCxcbiAgICAgICAgSWd4VGFic0dyb3VwQ29tcG9uZW50LFxuICAgICAgICBJZ3hUYWJJdGVtQ29tcG9uZW50LFxuICAgICAgICBJZ3hUYWJJdGVtVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgIElneFJpZ2h0QnV0dG9uU3R5bGVEaXJlY3RpdmUsXG4gICAgICAgIElneExlZnRCdXR0b25TdHlsZURpcmVjdGl2ZV0sXG4gICAgZXhwb3J0czogW0lneFRhYnNDb21wb25lbnQsXG4gICAgICAgIElneFRhYnNHcm91cENvbXBvbmVudCxcbiAgICAgICAgSWd4VGFiSXRlbUNvbXBvbmVudCxcbiAgICAgICAgSWd4VGFiSXRlbVRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICBJZ3hSaWdodEJ1dHRvblN0eWxlRGlyZWN0aXZlLFxuICAgICAgICBJZ3hMZWZ0QnV0dG9uU3R5bGVEaXJlY3RpdmVdLFxuICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIElneEJhZGdlTW9kdWxlLCBJZ3hJY29uTW9kdWxlLCBJZ3hSaXBwbGVNb2R1bGVdXG59KVxuXG5leHBvcnQgY2xhc3MgSWd4VGFic01vZHVsZSB7XG59XG4iXX0=