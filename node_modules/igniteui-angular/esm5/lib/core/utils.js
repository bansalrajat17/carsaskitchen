/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, PLATFORM_ID, Inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import * as i0 from "@angular/core";
/**
 * @hidden
 * @param {?} array
 * @param {?=} deep
 * @return {?}
 */
export function cloneArray(array, deep) {
    /** @type {?} */
    var arr = [];
    if (!array) {
        return arr;
    }
    /** @type {?} */
    var i = array.length;
    while (i--) {
        arr[i] = deep ? cloneValue(array[i]) : array[i];
    }
    return arr;
}
/**
 * Doesn't clone leaf items
 * @hidden
 * @param {?} array
 * @param {?} childDataKey
 * @return {?}
 */
export function cloneHierarchicalArray(array, childDataKey) {
    var e_1, _a;
    /** @type {?} */
    var result = [];
    if (!array) {
        return result;
    }
    try {
        for (var array_1 = tslib_1.__values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
            var item = array_1_1.value;
            /** @type {?} */
            var clonedItem = cloneValue(item);
            if (Array.isArray(item[childDataKey])) {
                clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
            }
            result.push(clonedItem);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return result;
}
/**
 * Deep clones all first level keys of Obj2 and merges them to Obj1
 * @hidden
 * @param {?} obj1 Object to merge into
 * @param {?} obj2 Object to merge from
 * @return {?} Obj1 with merged cloned keys from Obj2
 */
export function mergeObjects(obj1, obj2) {
    var e_2, _a;
    if (!isObject(obj1)) {
        throw new Error("Cannot merge into " + obj1 + ". First param must be an object.");
    }
    if (!isObject(obj2)) {
        return obj1;
    }
    try {
        for (var _b = tslib_1.__values(Object.keys(obj2)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            obj1[key] = cloneValue(obj2[key]);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return obj1;
}
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 * @hidden
 * @param {?} value value to clone
 * @return {?} Deep copy of provided value
 */
export function cloneValue(value) {
    var e_3, _a;
    if (isDate(value)) {
        return new Date(value.getTime());
    }
    if (Array.isArray(value)) {
        return tslib_1.__spread(value);
    }
    if (value instanceof Map || value instanceof Set) {
        return value;
    }
    if (isObject(value)) {
        /** @type {?} */
        var result = {};
        try {
            for (var _b = tslib_1.__values(Object.keys(value)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                result[key] = cloneValue(value[key]);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return result;
    }
    return value;
}
/**
 * Checks if provided variable is Object
 * @hidden
 * @param {?} value Value to check
 * @return {?} true if provided variable is Object
 */
export function isObject(value) {
    return value && value.toString() === '[object Object]';
}
/**
 * Checks if provided variable is Date
 * @hidden
 * @param {?} value Value to check
 * @return {?} true if provided variable is Date
 */
export function isDate(value) {
    return Object.prototype.toString.call(value) === '[object Date]';
}
/**
 * Checks if the two passed arguments are equal
 * Currently supports date objects
 * \@returns: `boolean`
 * @hidden
 * @param {?} obj1
 * @param {?} obj2
 * @return {?}
 */
export function isEqual(obj1, obj2) {
    if (isDate(obj1) && isDate(obj2)) {
        return obj1.getTime() === obj2.getTime();
    }
    return obj1 === obj2;
}
/** @enum {number} */
var KEYCODES = {
    ENTER: 13,
    SPACE: 32,
    ESCAPE: 27,
    LEFT_ARROW: 37,
    UP_ARROW: 38,
    RIGHT_ARROW: 39,
    DOWN_ARROW: 40,
    F2: 113,
    TAB: 9,
};
export { KEYCODES };
/** @enum {string} */
var KEYS = {
    ENTER: 'Enter',
    SPACE: ' ',
    SPACE_IE: 'Spacebar',
    ESCAPE: 'Escape',
    ESCAPE_IE: 'Esc',
    LEFT_ARROW: 'ArrowLeft',
    LEFT_ARROW_IE: 'Left',
    UP_ARROW: 'ArrowUp',
    UP_ARROW_IE: 'Up',
    RIGHT_ARROW: 'ArrowRight',
    RIGHT_ARROW_IE: 'Right',
    DOWN_ARROW: 'ArrowDown',
    DOWN_ARROW_IE: 'Down',
    F2: 'F2',
    TAB: 'Tab',
    HOME: 'Home',
    END: 'End',
};
export { KEYS };
/**
 * @hidden
 * Returns the actual size of the node content, using Range
 * ```typescript
 * let range = document.createRange();
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
 * ```
 * @param {?} range
 * @param {?} node
 * @return {?}
 */
export function getNodeSizeViaRange(range, node) {
    /** @type {?} */
    var overflow = null;
    if (!isFirefox()) {
        overflow = node.style.overflow;
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = 'visible';
    }
    range.selectNodeContents(node);
    /** @type {?} */
    var width = range.getBoundingClientRect().width;
    if (!isFirefox()) {
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = overflow;
    }
    return width;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Canvas
 * ```typescript
 * let ctx = document.createElement('canvas').getContext('2d');
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = valToPxlsUsingCanvas(ctx, column.cells[0].nativeElement);
 * ```
 * @param {?} canvas2dCtx
 * @param {?} node
 * @return {?}
 */
export function getNodeSizeViaCanvas(canvas2dCtx, node) {
    /** @type {?} */
    var s = this.grid.document.defaultView.getComputedStyle(node);
    // need to set the font to get correct width
    canvas2dCtx.font = s.fontSize + ' ' + s.fontFamily;
    return canvas2dCtx.measureText(node.textContent).width;
}
/**
 * @hidden
 * @return {?}
 */
export function isIE() {
    return navigator.appVersion.indexOf('Trident/') > 0;
}
/**
 * @hidden
 * @return {?}
 */
export function isEdge() {
    /** @type {?} */
    var edgeBrowser = /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return edgeBrowser;
}
/**
 * @hidden
 * @return {?}
 */
export function isFirefox() {
    /** @type {?} */
    var firefoxBrowser = /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return firefoxBrowser;
}
/**
 * @hidden
 */
var PlatformUtil = /** @class */ (function () {
    function PlatformUtil(platformId) {
        this.platformId = platformId;
        this.isBrowser = isPlatformBrowser(this.platformId);
        this.isIOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);
    }
    PlatformUtil.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    PlatformUtil.ctorParameters = function () { return [
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    /** @nocollapse */ PlatformUtil.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function PlatformUtil_Factory() { return new PlatformUtil(i0.ɵɵinject(i0.PLATFORM_ID)); }, token: PlatformUtil, providedIn: "root" });
    return PlatformUtil;
}());
export { PlatformUtil };
if (false) {
    /** @type {?} */
    PlatformUtil.prototype.isBrowser;
    /** @type {?} */
    PlatformUtil.prototype.isIOS;
    /**
     * @type {?}
     * @private
     */
    PlatformUtil.prototype.platformId;
}
/**
 * @hidden
 * @param {?} event
 * @return {?}
 */
export function isLeftClick(event) {
    return event.button === 0;
}
/**
 * @hidden
 * @param {?} key
 * @return {?}
 */
export function isNavigationKey(key) {
    return [
        'down',
        'up',
        'left',
        'right',
        'arrowdown',
        'arrowup',
        'arrowleft',
        'arrowright',
        'home',
        'end',
        'space',
        'spacebar',
        ' '
    ].indexOf(key) !== -1;
}
/**
 * @hidden
 * @param {?} arr
 * @return {?}
 */
export function flatten(arr) {
    /** @type {?} */
    var result = [];
    arr.forEach(function (el) {
        result.push(el);
        if (el.children) {
            /** @type {?} */
            var children = Array.isArray(el.children) ? el.children : el.children.toArray();
            result = result.concat(flatten(children));
        }
    });
    return result;
}
/**
 * @record
 */
export function CancelableEventArgs() { }
if (false) {
    /**
     * Provides the ability to cancel the event.
     * @type {?}
     */
    CancelableEventArgs.prototype.cancel;
}
/**
 * @record
 */
export function IBaseEventArgs() { }
if (false) {
    /**
     * Provides reference to the owner component.
     * @type {?|undefined}
     */
    IBaseEventArgs.prototype.owner;
}
/**
 * @record
 */
export function CancelableBrowserEventArgs() { }
if (false) {
    /**
     * Browser event
     * @type {?|undefined}
     */
    CancelableBrowserEventArgs.prototype.event;
}
/** @type {?} */
export var NAVIGATION_KEYS = new Set([
    'down',
    'up',
    'left',
    'right',
    'arrowdown',
    'arrowup',
    'arrowleft',
    'arrowright',
    'home',
    'end',
    'space',
    'spacebar',
    ' '
]);
/** @type {?} */
export var ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));
/** @type {?} */
export var ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));
/** @type {?} */
export var SUPPORTED_KEYS = new Set(tslib_1.__spread(Array.from(NAVIGATION_KEYS), ['tab', 'enter', 'f2', 'escape', 'esc']));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2NvcmUvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDaEUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7Ozs7Ozs7O0FBS3BELE1BQU0sVUFBVSxVQUFVLENBQUMsS0FBWSxFQUFFLElBQWM7O1FBQzdDLEdBQUcsR0FBRyxFQUFFO0lBQ2QsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNSLE9BQU8sR0FBRyxDQUFDO0tBQ2Q7O1FBQ0csQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNO0lBQ3BCLE9BQU8sQ0FBQyxFQUFFLEVBQUU7UUFDUixHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNuRDtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2YsQ0FBQzs7Ozs7Ozs7QUFNRCxNQUFNLFVBQVUsc0JBQXNCLENBQUMsS0FBWSxFQUFFLFlBQWlCOzs7UUFDNUQsTUFBTSxHQUFVLEVBQUU7SUFDeEIsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNSLE9BQU8sTUFBTSxDQUFDO0tBQ2pCOztRQUVELEtBQW1CLElBQUEsVUFBQSxpQkFBQSxLQUFLLENBQUEsNEJBQUEsK0NBQUU7WUFBckIsSUFBTSxJQUFJLGtCQUFBOztnQkFDTCxVQUFVLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQztZQUNuQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUU7Z0JBQ25DLFVBQVUsQ0FBQyxZQUFZLENBQUMsR0FBRyxz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QUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzs7QUFDcEYsTUFBTSxLQUFPLGlCQUFpQixHQUFHLElBQUksR0FBRyxDQUFDLDJCQUEyQixDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzs7QUFDaEYsTUFBTSxLQUFPLGNBQWMsR0FBRyxJQUFJLEdBQUcsa0JBQUssS0FBSyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsS0FBSyxHQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgUExBVEZPUk1fSUQsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVBcnJheShhcnJheTogYW55W10sIGRlZXA/OiBib29sZWFuKSB7XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgaWYgKCFhcnJheSkge1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICBsZXQgaSA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGFycltpXSA9IGRlZXAgPyBjbG9uZVZhbHVlKGFycmF5W2ldKSA6IGFycmF5W2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuXG4vKipcbiAqIERvZXNuJ3QgY2xvbmUgbGVhZiBpdGVtc1xuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVIaWVyYXJjaGljYWxBcnJheShhcnJheTogYW55W10sIGNoaWxkRGF0YUtleTogYW55KTogYW55W10ge1xuICAgIGNvbnN0IHJlc3VsdDogYW55W10gPSBbXTtcbiAgICBpZiAoIWFycmF5KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycmF5KSB7XG4gICAgICAgIGNvbnN0IGNsb25lZEl0ZW0gPSBjbG9uZVZhbHVlKGl0ZW0pO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtW2NoaWxkRGF0YUtleV0pKSB7XG4gICAgICAgICAgICBjbG9uZWRJdGVtW2NoaWxkRGF0YUtleV0gPSBjbG9uZUhpZXJhcmNoaWNhbEFycmF5KGNsb25lZEl0ZW1bY2hpbGREYXRhS2V5XSwgY2hpbGREYXRhS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChjbG9uZWRJdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZWVwIGNsb25lcyBhbGwgZmlyc3QgbGV2ZWwga2V5cyBvZiBPYmoyIGFuZCBtZXJnZXMgdGhlbSB0byBPYmoxXG4gKiBAcGFyYW0gb2JqMSBPYmplY3QgdG8gbWVyZ2UgaW50b1xuICogQHBhcmFtIG9iajIgT2JqZWN0IHRvIG1lcmdlIGZyb21cbiAqIEByZXR1cm5zIE9iajEgd2l0aCBtZXJnZWQgY2xvbmVkIGtleXMgZnJvbSBPYmoyXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZU9iamVjdHMob2JqMToge30sIG9iajI6IHt9KTogYW55IHtcbiAgICBpZiAoIWlzT2JqZWN0KG9iajEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG1lcmdlIGludG8gJHtvYmoxfS4gRmlyc3QgcGFyYW0gbXVzdCBiZSBhbiBvYmplY3QuYCk7XG4gICAgfVxuXG4gICAgaWYgKCFpc09iamVjdChvYmoyKSkge1xuICAgICAgICByZXR1cm4gb2JqMTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmoyKSkge1xuICAgICAgICBvYmoxW2tleV0gPSBjbG9uZVZhbHVlKG9iajJba2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajE7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBkZWVwIGNsb25lIG9mIHByb3ZpZGVkIHZhbHVlLlxuICogU3VwcG9ydHMgcHJpbWl0aXZlIHZhbHVlcywgZGF0ZXMgYW5kIG9iamVjdHMuXG4gKiBJZiBwYXNzZWQgdmFsdWUgaXMgYXJyYXkgcmV0dXJucyBzaGFsbG93IGNvcHkgb2YgdGhlIGFycmF5LlxuICogQHBhcmFtIHZhbHVlIHZhbHVlIHRvIGNsb25lXG4gKiBAcmV0dXJucyBEZWVwIGNvcHkgb2YgcHJvdmlkZWQgdmFsdWVcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVWYWx1ZSh2YWx1ZTogYW55KTogYW55IHtcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUuZ2V0VGltZSgpKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBbLi4udmFsdWVdO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gY2xvbmVWYWx1ZSh2YWx1ZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHByb3ZpZGVkIHZhcmlhYmxlIGlzIE9iamVjdFxuICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB0cnVlIGlmIHByb3ZpZGVkIHZhcmlhYmxlIGlzIE9iamVjdFxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBwcm92aWRlZCB2YXJpYWJsZSBpcyBEYXRlXG4gKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHRydWUgaWYgcHJvdmlkZWQgdmFyaWFibGUgaXMgRGF0ZVxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUodmFsdWU6IGFueSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSB0d28gcGFzc2VkIGFyZ3VtZW50cyBhcmUgZXF1YWxcbiAqIEN1cnJlbnRseSBzdXBwb3J0cyBkYXRlIG9iamVjdHNcbiAqIEBwYXJhbSBvYmoxXG4gKiBAcGFyYW0gb2JqMlxuICogQHJldHVybnM6IGBib29sZWFuYFxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVhbChvYmoxLCBvYmoyKTogYm9vbGVhbiB7XG4gICAgaWYgKGlzRGF0ZShvYmoxKSAmJiBpc0RhdGUob2JqMikpIHtcbiAgICAgICAgcmV0dXJuIG9iajEuZ2V0VGltZSgpID09PSBvYmoyLmdldFRpbWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG59XG5cbi8qKlxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIEtFWUNPREVTIHtcbiAgICBFTlRFUiA9IDEzLFxuICAgIFNQQUNFID0gMzIsXG4gICAgRVNDQVBFID0gMjcsXG4gICAgTEVGVF9BUlJPVyA9IDM3LFxuICAgIFVQX0FSUk9XID0gMzgsXG4gICAgUklHSFRfQVJST1cgPSAzOSxcbiAgICBET1dOX0FSUk9XID0gNDAsXG4gICAgRjIgPSAxMTMsXG4gICAgVEFCID0gOVxufVxuXG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgY29uc3QgZW51bSBLRVlTIHtcbiAgICBFTlRFUiA9ICdFbnRlcicsXG4gICAgU1BBQ0UgPSAnICcsXG4gICAgU1BBQ0VfSUUgPSAnU3BhY2ViYXInLFxuICAgIEVTQ0FQRSA9ICdFc2NhcGUnLFxuICAgIEVTQ0FQRV9JRSA9ICdFc2MnLFxuICAgIExFRlRfQVJST1cgPSAnQXJyb3dMZWZ0JyxcbiAgICBMRUZUX0FSUk9XX0lFID0gJ0xlZnQnLFxuICAgIFVQX0FSUk9XID0gJ0Fycm93VXAnLFxuICAgIFVQX0FSUk9XX0lFID0gJ1VwJyxcbiAgICBSSUdIVF9BUlJPVyA9ICdBcnJvd1JpZ2h0JyxcbiAgICBSSUdIVF9BUlJPV19JRSA9ICdSaWdodCcsXG4gICAgRE9XTl9BUlJPVyA9ICdBcnJvd0Rvd24nLFxuICAgIERPV05fQVJST1dfSUUgPSAnRG93bicsXG4gICAgRjIgPSAnRjInLFxuICAgIFRBQiA9ICdUYWInLFxuICAgIEhPTUUgPSAnSG9tZScsXG4gICAgRU5EID0gJ0VuZCdcbn1cblxuLyoqXG4gKkBoaWRkZW5cbiogUmV0dXJucyB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIG5vZGUgY29udGVudCwgdXNpbmcgUmFuZ2VcbiogYGBgdHlwZXNjcmlwdFxuKiBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4qXG4qIGxldCBzaXplID0gZ2V0Tm9kZVNpemVWaWFSYW5nZShyYW5nZSwgY29sdW1uLmNlbGxzWzBdLm5hdGl2ZUVsZW1lbnQpO1xuKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVTaXplVmlhUmFuZ2UocmFuZ2U6IFJhbmdlLCBub2RlOiBhbnkpOiBudW1iZXIge1xuICAgIGxldCBvdmVyZmxvdyA9IG51bGw7XG4gICAgaWYgKCFpc0ZpcmVmb3goKSkge1xuICAgICAgICBvdmVyZmxvdyA9IG5vZGUuc3R5bGUub3ZlcmZsb3c7XG4gICAgICAgIC8vIHdlIG5lZWQgdGhhdCBoYWNrIC0gb3RoZXJ3aXNlIGNvbnRlbnQgd29uJ3QgYmUgbWVhc3VyZWQgY29ycmVjdGx5IGluIElFL0VkZ2VcbiAgICAgICAgbm9kZS5zdHlsZS5vdmVyZmxvdyA9ICd2aXNpYmxlJztcbiAgICB9XG5cbiAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMobm9kZSk7XG4gICAgY29uc3Qgd2lkdGggPSByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblxuICAgIGlmICghaXNGaXJlZm94KCkpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0aGF0IGhhY2sgLSBvdGhlcndpc2UgY29udGVudCB3b24ndCBiZSBtZWFzdXJlZCBjb3JyZWN0bHkgaW4gSUUvRWRnZVxuICAgICAgICBub2RlLnN0eWxlLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpZHRoO1xufVxuLyoqXG4gKkBoaWRkZW5cbiogUmV0dXJucyB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIG5vZGUgY29udGVudCwgdXNpbmcgQ2FudmFzXG4qIGBgYHR5cGVzY3JpcHRcbiogbGV0IGN0eCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG4qIGxldCBjb2x1bW4gPSB0aGlzLmdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLmZpZWxkID09PSAnSUQnKVswXTtcbipcbiogbGV0IHNpemUgPSB2YWxUb1B4bHNVc2luZ0NhbnZhcyhjdHgsIGNvbHVtbi5jZWxsc1swXS5uYXRpdmVFbGVtZW50KTtcbiogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlU2l6ZVZpYUNhbnZhcyhjYW52YXMyZEN0eDogYW55LCBub2RlOiBhbnkpOiBudW1iZXIge1xuICAgIGNvbnN0IHMgPSB0aGlzLmdyaWQuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblxuICAgIC8vIG5lZWQgdG8gc2V0IHRoZSBmb250IHRvIGdldCBjb3JyZWN0IHdpZHRoXG4gICAgY2FudmFzMmRDdHguZm9udCA9IHMuZm9udFNpemUgKyAnICcgKyBzLmZvbnRGYW1pbHk7XG5cbiAgICByZXR1cm4gY2FudmFzMmRDdHgubWVhc3VyZVRleHQobm9kZS50ZXh0Q29udGVudCkud2lkdGg7XG59XG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJRSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLmFwcFZlcnNpb24uaW5kZXhPZignVHJpZGVudC8nKSA+IDA7XG59XG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFZGdlKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGVkZ2VCcm93c2VyID0gL0VkZ2VbXFwvXFxzXShcXGQrXFwuXFxkKykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgcmV0dXJuIGVkZ2VCcm93c2VyO1xufVxuXG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGaXJlZm94KCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGZpcmVmb3hCcm93c2VyID0gL0ZpcmVmb3hbXFwvXFxzXShcXGQrXFwuXFxkKykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgcmV0dXJuIGZpcmVmb3hCcm93c2VyO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBQbGF0Zm9ybVV0aWwge1xuICAgIHB1YmxpYyBpc0Jyb3dzZXI6IGJvb2xlYW4gPSBpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpO1xuXG4gICAgcHVibGljIGlzSU9TID0gdGhpcy5pc0Jyb3dzZXIgJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgISgnTVNTdHJlYW0nIGluIHdpbmRvdyk7XG5cbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IE9iamVjdCkge1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xlZnRDbGljayhldmVudDogUG9pbnRlckV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmJ1dHRvbiA9PT0gMDtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc05hdmlnYXRpb25LZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAnZG93bicsXG4gICAgICAgICd1cCcsXG4gICAgICAgICdsZWZ0JyxcbiAgICAgICAgJ3JpZ2h0JyxcbiAgICAgICAgJ2Fycm93ZG93bicsXG4gICAgICAgICdhcnJvd3VwJyxcbiAgICAgICAgJ2Fycm93bGVmdCcsXG4gICAgICAgICdhcnJvd3JpZ2h0JyxcbiAgICAgICAgJ2hvbWUnLFxuICAgICAgICAnZW5kJyxcbiAgICAgICAgJ3NwYWNlJyxcbiAgICAgICAgJ3NwYWNlYmFyJyxcbiAgICAgICAgJyAnXG4gICAgXS5pbmRleE9mKGtleSkgIT09IC0xO1xufVxuXG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbihhcnI6IGFueVtdKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gICAgYXJyLmZvckVhY2goZWwgPT4ge1xuICAgICAgICByZXN1bHQucHVzaChlbCk7XG4gICAgICAgIGlmIChlbC5jaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBBcnJheS5pc0FycmF5KGVsLmNoaWxkcmVuKSA/IGVsLmNoaWxkcmVuIDogZWwuY2hpbGRyZW4udG9BcnJheSgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChmbGF0dGVuKGNoaWxkcmVuKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhbmNlbGFibGVFdmVudEFyZ3Mge1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIGNhbmNlbCB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgY2FuY2VsOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElCYXNlRXZlbnRBcmdzIHtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyByZWZlcmVuY2UgdG8gdGhlIG93bmVyIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBvd25lcj86IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYW5jZWxhYmxlQnJvd3NlckV2ZW50QXJncyBleHRlbmRzIENhbmNlbGFibGVFdmVudEFyZ3Mge1xuICAgIC8qKiBCcm93c2VyIGV2ZW50ICovXG4gICAgZXZlbnQ/OiBFdmVudDtcbn1cblxuZXhwb3J0IGNvbnN0IE5BVklHQVRJT05fS0VZUyA9IG5ldyBTZXQoW1xuICAgICdkb3duJyxcbiAgICAndXAnLFxuICAgICdsZWZ0JyxcbiAgICAncmlnaHQnLFxuICAgICdhcnJvd2Rvd24nLFxuICAgICdhcnJvd3VwJyxcbiAgICAnYXJyb3dsZWZ0JyxcbiAgICAnYXJyb3dyaWdodCcsXG4gICAgJ2hvbWUnLFxuICAgICdlbmQnLFxuICAgICdzcGFjZScsXG4gICAgJ3NwYWNlYmFyJyxcbiAgICAnICdcbl0pO1xuZXhwb3J0IGNvbnN0IFJPV19FWFBBTkRfS0VZUyA9IG5ldyBTZXQoJ3JpZ2h0IGRvd24gYXJyb3dyaWdodCBhcnJvd2Rvd24nLnNwbGl0KCcgJykpO1xuZXhwb3J0IGNvbnN0IFJPV19DT0xMQVBTRV9LRVlTID0gbmV3IFNldCgnbGVmdCB1cCBhcnJvd2xlZnQgYXJyb3d1cCcuc3BsaXQoJyAnKSk7XG5leHBvcnQgY29uc3QgU1VQUE9SVEVEX0tFWVMgPSBuZXcgU2V0KFsuLi5BcnJheS5mcm9tKE5BVklHQVRJT05fS0VZUyksICd0YWInLCAnZW50ZXInLCAnZjInLCAnZXNjYXBlJywgJ2VzYyddKTtcbiJdfQ==