/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, Input, QueryList, TemplateRef, forwardRef, Output, EventEmitter } from '@angular/core';
import { WatchColumnChanges } from './watch-changes';
import { IgxRowIslandAPIService } from './hierarchical-grid/row-island-api.service';
import { DataType } from '../data-operations/data-util';
import { GridBaseAPIService } from './api.service';
import { IgxDateSummaryOperand, IgxNumberSummaryOperand, IgxSummaryOperand } from './summaries/grid-summary';
import { IgxRowComponent } from './row.component';
import { DefaultSortingStrategy } from '../data-operations/sorting-strategy';
import { getNodeSizeViaRange, flatten } from '../core/utils';
import { IgxBooleanFilteringOperand, IgxNumberFilteringOperand, IgxDateFilteringOperand, IgxStringFilteringOperand, IgxFilteringOperand } from '../data-operations/filtering-condition';
import { DeprecateProperty } from '../core/deprecateDecorators';
import { DisplayDensity } from '../core/displayDensity';
import { notifyChanges } from './watch-changes';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { IgxCellTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellEditorTemplateDirective, IgxFilterCellTemplateDirective } from './common/templates';
/**
 * **Ignite UI for Angular Column** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html#columns-configuration)
 *
 * The Ignite UI Column is used within an `igx-grid` element to define what data the column will show. Features such as sorting,
 * filtering & editing are enabled at the column level.  You can also provide a template containing custom content inside
 * the column using `ng-template` which will be used for all cells within the column.
 */
var IgxColumnComponent = /** @class */ (function () {
    function IgxColumnComponent(gridAPI, cdr, rowIslandAPI) {
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.rowIslandAPI = rowIslandAPI;
        /**
         * Sets/gets the `header` value.
         * ```typescript
         * let columnHeader = this.column.header;
         * ```
         * ```html
         * <igx-column [header] = "'ID'"></igx-column>
         * ```
         *
         * \@memberof IgxColumnComponent
         */
        this.header = '';
        /**
         * Sets/gets whether the column is sortable.
         * Default value is `false`.
         * ```typescript
         * let isSortable = this.column.sortable;
         * ```
         * ```html
         * <igx-column [sortable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.sortable = false;
        /**
         * Sets/gets whether the column is groupable.
         * Default value is `false`.
         * ```typescript
         * let isGroupable = this.column.groupable;
         * ```
         * ```html
         * <igx-column [groupable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.groupable = false;
        /**
         * Sets/gets whether the column is filterable.
         * Default value is `true`.
         * ```typescript
         * let isFilterable = this.column.filterable;
         * ```
         * ```html
         * <igx-column [filterable] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.filterable = true;
        /**
         * Sets/gets whether the column is resizable.
         * Default value is `false`.
         * ```typescript
         * let isResizable = this.column.resizable;
         * ```
         * ```html
         * <igx-column [resizable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.resizable = false;
        /**
         * @hidden
         */
        this.hiddenChange = new EventEmitter();
        /**
         * Gets whether the hiding is disabled.
         * ```typescript
         * let isHidingDisabled =  this.column.disableHiding;
         * ```
         * \@memberof IgxColumnComponent
         */
        this.disableHiding = false;
        /**
         * Gets whether the pinning is disabled.
         * ```typescript
         * let isPinningDisabled =  this.column.disablePinning;
         * ```
         * \@memberof IgxColumnComponent
         */
        this.disablePinning = false;
        /**
         * Sets/gets whether the column is movable.
         * Default value is `false`.
         * ```typescript
         * let isMovable = this.column.movable;
         * ```
         * ```html
         * <igx-column [movable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.movable = false;
        /**
         * @hidden
         */
        this.widthChange = new EventEmitter();
        this._calcWidth = null;
        /**
         * Sets/gets the class selector of the column header.
         * ```typescript
         * let columnHeaderClass = this.column.headerClasses;
         * ```
         * ```html
         * <igx-column [headerClasses] = "'column-header'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.headerClasses = '';
        /**
         * Sets/gets the class selector of the column group header.
         * ```typescript
         * let columnHeaderClass = this.column.headerGroupClasses;
         * ```
         * ```html
         * <igx-column [headerGroupClasses] = "'column-group-header'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.headerGroupClasses = '';
        /**
         * Sets conditional style properties on the column cells.
         * Similar to `ngStyle` it accepts an object literal where the keys are
         * the style properties and the value is the expression to be evaluated.
         * As with `cellClasses` it accepts a callback function.
         * ```typescript
         * styles = {
         *  background: 'royalblue',
         *  color: (rowData, columnKey, cellValue, rowIndex) => value.startsWith('Important') : 'red': 'inherit'
         * }
         * ```
         * ```html
         * <igx-column [cellStyles]="styles"></igx-column>
         * ```
         *
         * \@memberof IgxColumnComponent
         */
        this.cellStyles = null;
        /**
         * Sets/gets whether the column filtering should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let filteringIgnoreCase = this.column.filteringIgnoreCase;
         * ```
         * ```html
         * <igx-column [filteringIgnoreCase] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.filteringIgnoreCase = true;
        /**
         * Sets/gets whether the column sorting should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let sortingIgnoreCase = this.column.sortingIgnoreCase;
         * ```
         * ```html
         * <igx-column [sortingIgnoreCase] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.sortingIgnoreCase = true;
        /**
         * Sets/gets the data type of the column values.
         * Default value is `string`.
         * ```typescript
         * let columnDataType = this.column.dataType;
         * ```
         * ```html
         * <igx-column [dataType] = "'number'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.dataType = DataType.String;
        /**
         * @hidden
         */
        this.pinnedChange = new EventEmitter();
        /**
         * Sets/gets whether the column is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.column.searchable';
         * ```
         * ```html
         *  <igx-column [searchable] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.searchable = true;
        /**
         * Sets/gets the parent column.
         * ```typescript
         * let parentColumn = this.column.parent;
         * ```
         * ```typescript
         * this.column.parent = higherLevelColumn;
         * ```
         * \@memberof IgxColumnComponent
         */
        this.parent = null;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        /**
         * @hidden
         */
        this._pinned = false;
        /**
         * @hidden
         */
        this._summaries = null;
        /**
         * @hidden
         */
        this._filters = null;
        /**
         * @hidden
         */
        this._sortStrategy = DefaultSortingStrategy.instance();
        /**
         * @hidden
         */
        this._hidden = false;
        /**
         * @hidden
         */
        this._disablePinning = false;
        /**
         * @hidden
         */
        this._defaultMinWidth = '';
        /**
         * @hidden
         */
        this._hasSummary = false;
        this._vIndex = NaN;
    }
    Object.defineProperty(IgxColumnComponent.prototype, "editable", {
        /**
         * Gets whether the column is editable.
         * Default value is `false`.
         * ```typescript
         * let isEditable = this.column.editable;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets whether the column is editable.
         * Default value is `false`.
         * ```typescript
         * let isEditable = this.column.editable;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            // Updating the primary key when grid has transactions (incl. row edit)
            // should not be allowed, as that can corrupt transaction state.
            /** @type {?} */
            var rowEditable = this.grid && this.grid.rowEditable;
            /** @type {?} */
            var hasTransactions = this.grid && this.grid.transactions.enabled;
            if (this.isPrimaryColumn && (rowEditable || hasTransactions)) {
                return false;
            }
            if (this._editable !== undefined) {
                return this._editable;
            }
            else {
                return rowEditable;
            }
        },
        /**
         * Sets whether the column is editable.
         * ```typescript
         * this.column.editable = true;
         * ```
         * ```html
         * <igx-column [editable] = "true"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets whether the column is editable.
         * ```typescript
         * this.column.editable = true;
         * ```
         * ```html
         * <igx-column [editable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} editable
         * @return {?}
         */
        function (editable) {
            this._editable = editable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "hasSummary", {
        /**
         * Gets a value indicating whether the summary for the column is enabled.
         * ```typescript
         * let hasSummary = this.column.hasSummary;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets a value indicating whether the summary for the column is enabled.
         * ```typescript
         * let hasSummary = this.column.hasSummary;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._hasSummary;
        },
        /**
         * Sets a value indicating whether the summary for the column is enabled.
         * Default value is `false`.
         * ```html
         * <igx-column [hasSummary] = "true"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets a value indicating whether the summary for the column is enabled.
         * Default value is `false`.
         * ```html
         * <igx-column [hasSummary] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._hasSummary = value;
            if (this.grid) {
                this.grid.summaryService.resetSummaryHeight();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "hidden", {
        /**
         * Gets whether the column is hidden.
         * ```typescript
         * let isHidden = this.column.hidden;
         * ```
         *@memberof IgxColumnComponent
         */
        get: /**
         * Gets whether the column is hidden.
         * ```typescript
         * let isHidden = this.column.hidden;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._hidden;
        },
        /**
         * Sets the column hidden property.
         * Default value is `false`.
         * ```html
         * <igx-column [hidden] = "true"></igx-column>
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-column [(hidden)] = "model.isHidden"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the column hidden property.
         * Default value is `false`.
         * ```html
         * <igx-column [hidden] = "true"></igx-column>
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-column [(hidden)] = "model.isHidden"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._hidden !== value) {
                this._hidden = value;
                this.hiddenChange.emit(this._hidden);
                if (this.columnLayoutChild && this.parent.hidden !== value) {
                    this.parent.hidden = value;
                    return;
                }
                if (this.grid) {
                    this.grid.endEdit(false);
                    this.grid.summaryService.resetSummaryHeight();
                    this.grid.filteringService.refreshExpressions();
                    this.grid.filteringService.hideFilteringRowOnColumnVisibilityChange(this);
                    this.grid.notifyChanges();
                    // this.grid.refreshSearch(true);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "width", {
        /**
         * Gets the `width` of the column.
         * ```typescript
         * let columnWidth = this.column.width;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the `width` of the column.
         * ```typescript
         * let columnWidth = this.column.width;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this.widthSetByUser ? this._width : this.defaultWidth;
        },
        /**
         * Sets the `width` of the column.
         * ```html
         * <igx-column [width] = "'25%'"></igx-column>
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-column [(width)]="model.columns[0].width"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the `width` of the column.
         * ```html
         * <igx-column [width] = "'25%'"></igx-column>
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-column [(width)]="model.columns[0].width"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this._calcWidth = null;
                this.calcPixelWidth = NaN;
                this.widthSetByUser = true;
                this._width = value;
                if (this.grid) {
                    this.cacheCalcWidth();
                }
                this.widthChange.emit(this._width);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "calcWidth", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.getCalcWidth();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "minWidth", {
        get: /**
         * @return {?}
         */
        function () {
            return !this._defaultMinWidth ? this.defaultMinWidth : this._defaultMinWidth;
        },
        /**
         * Sets/gets the minimum `width` of the column.
         * Default value is `88`;
         * ```typescript
         * let columnMinWidth = this.column.minWidth;
         * ```
         * ```html
         * <igx-column [minWidth] = "'15%'"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets/gets the minimum `width` of the column.
         * Default value is `88`;
         * ```typescript
         * let columnMinWidth = this.column.minWidth;
         * ```
         * ```html
         * <igx-column [minWidth] = "'15%'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var minVal = parseFloat(value);
            if (Number.isNaN(minVal)) {
                return;
            }
            this._defaultMinWidth = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "index", {
        /**
         * Gets the column index.
         * ```typescript
         * let columnIndex = this.column.index;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the column index.
         * ```typescript
         * let columnIndex = this.column.index;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this.grid.columns.indexOf(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "pinned", {
        /**
         * Gets whether the column is `pinned`.
         * ```typescript
         * let isPinned = this.column.pinned;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets whether the column is `pinned`.
         * ```typescript
         * let isPinned = this.column.pinned;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._pinned;
        },
        /**
         * Sets whether the column is pinned.
         * Default value is `false`.
         * ```html
         * <igx-column [pinned] = "true"></igx-column>
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-column [(pinned)] = "model.columns[0].isPinned"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets whether the column is pinned.
         * Default value is `false`.
         * ```html
         * <igx-column [pinned] = "true"></igx-column>
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-column [(pinned)] = "model.columns[0].isPinned"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._pinned !== value) {
                if (this.grid && this.width && !isNaN(parseInt(this.width, 10))) {
                    value ? this.pin() : this.unpin();
                    return;
                }
                /* No grid/width available at initialization. `initPinning` in the grid
                   will re-init the group (if present)
                */
                this._pinned = value;
                this.pinnedChange.emit(this._pinned);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "summaries", {
        /**
         * Gets the column `summaries`.
         * ```typescript
         * let columnSummaries = this.column.summaries;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the column `summaries`.
         * ```typescript
         * let columnSummaries = this.column.summaries;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._summaries;
        },
        /**
         * Sets the column `summaries`.
         * ```typescript
         * this.column.summaries = IgxNumberSummaryOperand;
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the column `summaries`.
         * ```typescript
         * this.column.summaries = IgxNumberSummaryOperand;
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} classRef
         * @return {?}
         */
        function (classRef) {
            this._summaries = new classRef();
            if (this.grid) {
                this.grid.summaryService.removeSummariesCachePerColumn(this.field);
                ((/** @type {?} */ (this.grid)))._summaryPipeTrigger++;
                this.grid.summaryService.resetSummaryHeight();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "filters", {
        /**
         * Gets the column `filters`.
         * ```typescript
         * let columnFilters = this.column.filters'
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the column `filters`.
         * ```typescript
         * let columnFilters = this.column.filters'
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._filters;
        },
        /**
         * Sets the column `filters`.
         * ```typescript
         * this.column.filters = IgxBooleanFilteringOperand.instance().
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the column `filters`.
         * ```typescript
         * this.column.filters = IgxBooleanFilteringOperand.instance().
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} instance
         * @return {?}
         */
        function (instance) {
            this._filters = instance;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "sortStrategy", {
        /**
         * Gets the column `sortStrategy`.
         * ```typescript
         * let sortStrategy = this.column.sortStrategy
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the column `sortStrategy`.
         * ```typescript
         * let sortStrategy = this.column.sortStrategy
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._sortStrategy;
        },
        /**
         * Sets the column `sortStrategy`.
         * ```typescript
         * this.column.sortStrategy = new CustomSortingStrategy().
         * class CustomSortingStrategy extends SortingStrategy {...}
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the column `sortStrategy`.
         * ```typescript
         * this.column.sortStrategy = new CustomSortingStrategy().
         * class CustomSortingStrategy extends SortingStrategy {...}
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} classRef
         * @return {?}
         */
        function (classRef) {
            this._sortStrategy = classRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "groupingComparer", {
        /**
        * Gets the function that compares values for grouping.
        * ```typescript
        * let groupingComparer = this.column.groupingComparer'
        * ```
        * @memberof IgxColumnComponent
        */
        get: /**
         * Gets the function that compares values for grouping.
         * ```typescript
         * let groupingComparer = this.column.groupingComparer'
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._groupingComparer;
        },
        /**
         * Sets a custom function to compare values for grouping.
         * Subsequent values in the sorted data that the function returns 0 for are grouped.
         * ```typescript
         * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets a custom function to compare values for grouping.
         * Subsequent values in the sorted data that the function returns 0 for are grouped.
         * ```typescript
         * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} funcRef
         * @return {?}
         */
        function (funcRef) {
            this._groupingComparer = funcRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "defaultMinWidth", {
        /**
         * Gets the default minimum `width` of the column.
         * ```typescript
         * let defaultMinWidth =  this.column.defaultMinWidth;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the default minimum `width` of the column.
         * ```typescript
         * let defaultMinWidth =  this.column.defaultMinWidth;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            if (!this.grid) {
                return '80';
            }
            switch (this.grid.displayDensity) {
                case DisplayDensity.cosy:
                    return '64';
                case DisplayDensity.compact:
                    return '56';
                default:
                    return '80';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "grid", {
        /**
         * The reference to the `igx-grid` owner.
         * ```typescript
         * let gridComponent = this.column.grid;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * The reference to the `igx-grid` owner.
         * ```typescript
         * let gridComponent = this.column.grid;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this.gridAPI.grid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "bodyTemplate", {
        /**
         * Returns a reference to the `bodyTemplate`.
         * ```typescript
         * let bodyTemplate = this.column.bodyTemplate;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a reference to the `bodyTemplate`.
         * ```typescript
         * let bodyTemplate = this.column.bodyTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._bodyTemplate;
        },
        /**
         * Sets the body template.
         * ```html
         * <ng-template #bodyTemplate igxCell let-val>
         *    <div style = "background-color: yellowgreen" (click) = "changeColor(val)">
         *       <span> {{val}} </span>
         *    </div>
         * </ng-template>
         * ```
         * ```typescript
         * @ViewChild("'bodyTemplate'", {read: TemplateRef })
         * public bodyTemplate: TemplateRef<any>;
         * this.column.bodyTemplate = this.bodyTemplate;
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the body template.
         * ```html
         * <ng-template #bodyTemplate igxCell let-val>
         *    <div style = "background-color: yellowgreen" (click) = "changeColor(val)">
         *       <span> {{val}} </span>
         *    </div>
         * </ng-template>
         * ```
         * ```typescript
         * \@ViewChild("'bodyTemplate'", {read: TemplateRef })
         * public bodyTemplate: TemplateRef<any>;
         * this.column.bodyTemplate = this.bodyTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._bodyTemplate = template;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "headerTemplate", {
        /**
         * Returns a reference to the header template.
         * ```typescript
         * let headerTemplate = this.column.headerTemplate;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a reference to the header template.
         * ```typescript
         * let headerTemplate = this.column.headerTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._headerTemplate;
        },
        /**
         * Sets the header template.
         * Note that the column header height is fixed and any content bigger than it will be cut off.
         * ```html
         * <ng-template #headerTemplate>
         *   <div style = "background-color:black" (click) = "changeColor(val)">
         *       <span style="color:red" >{{column.field}}</span>
         *   </div>
         * </ng-template>
         * ```
         * ```typescript
         * @ViewChild("'headerTemplate'", {read: TemplateRef })
         * public headerTemplate: TemplateRef<any>;
         * this.column.headerTemplate = this.headerTemplate;
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the header template.
         * Note that the column header height is fixed and any content bigger than it will be cut off.
         * ```html
         * <ng-template #headerTemplate>
         *   <div style = "background-color:black" (click) = "changeColor(val)">
         *       <span style="color:red" >{{column.field}}</span>
         *   </div>
         * </ng-template>
         * ```
         * ```typescript
         * \@ViewChild("'headerTemplate'", {read: TemplateRef })
         * public headerTemplate: TemplateRef<any>;
         * this.column.headerTemplate = this.headerTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._headerTemplate = template;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "inlineEditorTemplate", {
        /**
         * Returns a reference to the inline editor template.
         * ```typescript
         * let inlineEditorTemplate = this.column.inlineEditorTemplate;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a reference to the inline editor template.
         * ```typescript
         * let inlineEditorTemplate = this.column.inlineEditorTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._inlineEditorTemplate;
        },
        /**
         * Sets the inline editor template.
         * ```html
         * <ng-template #inlineEditorTemplate igxCellEditor let-cell="cell">
         *     <input type="string" [(ngModel)]="cell.value"/>
         * </ng-template>
         * ```
         * ```typescript
         * @ViewChild("'inlineEditorTemplate'", {read: TemplateRef })
         * public inlineEditorTemplate: TemplateRef<any>;
         * this.column.inlineEditorTemplate = this.inlineEditorTemplate;
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the inline editor template.
         * ```html
         * <ng-template #inlineEditorTemplate igxCellEditor let-cell="cell">
         *     <input type="string" [(ngModel)]="cell.value"/>
         * </ng-template>
         * ```
         * ```typescript
         * \@ViewChild("'inlineEditorTemplate'", {read: TemplateRef })
         * public inlineEditorTemplate: TemplateRef<any>;
         * this.column.inlineEditorTemplate = this.inlineEditorTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._inlineEditorTemplate = template;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "filterCellTemplate", {
        /**
         * Returns a reference to the `filterCellTemplate`.
         * ```typescript
         * let filterCellTemplate = this.column.filterCellTemplate;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a reference to the `filterCellTemplate`.
         * ```typescript
         * let filterCellTemplate = this.column.filterCellTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._filterCellTemplate;
        },
        /**
         * Sets the quick filter template.
         * ```html
         * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column="column">
         *    <input (input)="onInput()">
         * </ng-template>
         * ```
         * ```typescript
         * @ViewChild("'filterCellTemplate'", {read: TemplateRef })
         * public filterCellTemplate: TemplateRef<any>;
         * this.column.filterCellTemplate = this.filterCellTemplate;
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the quick filter template.
         * ```html
         * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column="column">
         *    <input (input)="onInput()">
         * </ng-template>
         * ```
         * ```typescript
         * \@ViewChild("'filterCellTemplate'", {read: TemplateRef })
         * public filterCellTemplate: TemplateRef<any>;
         * this.column.filterCellTemplate = this.filterCellTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._filterCellTemplate = template;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "cells", {
        /**
         * Gets the cells of the column.
         * ```typescript
         * let columnCells =  this.column.cells;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the cells of the column.
         * ```typescript
         * let columnCells =  this.column.cells;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            var _this = this;
            return this.grid.rowList.filter(function (row) { return row instanceof IgxRowComponent; })
                .map(function (row) {
                if (row.cells) {
                    return row.cells.filter(function (cell) { return cell.columnIndex === _this.index; });
                }
            }).reduce(function (a, b) { return a.concat(b); }, []);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "visibleIndex", {
        /**
         * Gets the column visible index.
         * If the column is not visible, returns `-1`.
         * ```typescript
         * let visibleColumnIndex =  this.column.visibleIndex;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the column visible index.
         * If the column is not visible, returns `-1`.
         * ```typescript
         * let visibleColumnIndex =  this.column.visibleIndex;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            var _this = this;
            if (!isNaN(this._vIndex)) {
                return this._vIndex;
            }
            /** @type {?} */
            var unpinnedColumns = this.grid.unpinnedColumns.filter(function (c) { return !c.columnGroup; });
            /** @type {?} */
            var pinnedColumns = this.grid.pinnedColumns.filter(function (c) { return !c.columnGroup; });
            /** @type {?} */
            var col = this;
            /** @type {?} */
            var vIndex = -1;
            if (this.columnGroup) {
                col = (/** @type {?} */ (this.allChildren.filter(function (c) { return !c.columnGroup; })[0]));
            }
            if (this.columnLayoutChild) {
                return this.parent.childrenVisibleIndexes.find(function (x) { return x.column === _this; }).index;
            }
            if (!this.pinned) {
                /** @type {?} */
                var indexInCollection = unpinnedColumns.indexOf(col);
                vIndex = indexInCollection === -1 ? -1 : pinnedColumns.length + indexInCollection;
            }
            else {
                vIndex = pinnedColumns.indexOf(col);
            }
            this._vIndex = vIndex;
            return vIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "columnGroup", {
        /**
         * Returns a boolean indicating if the column is a `ColumnGroup`.
         * ```typescript
         * let columnGroup =  this.column.columnGroup;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a boolean indicating if the column is a `ColumnGroup`.
         * ```typescript
         * let columnGroup =  this.column.columnGroup;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "columnLayout", {
        /**
         * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
         * ```typescript
         * let columnGroup =  this.column.columnGroup;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
         * ```typescript
         * let columnGroup =  this.column.columnGroup;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "columnLayoutChild", {
        /**
        * Returns a boolean indicating if the column is a child of a `ColumnLayout` for multi-row layout.
        * ```typescript
        * let columnLayoutChild =  this.column.columnLayoutChild;
        * ```
        * @memberof IgxColumnComponent
        */
        get: /**
         * Returns a boolean indicating if the column is a child of a `ColumnLayout` for multi-row layout.
         * ```typescript
         * let columnLayoutChild =  this.column.columnLayoutChild;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this.parent && this.parent.columnLayout;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "allChildren", {
        /**
         * Returns the children columns collection.
         * Returns an empty array if the column does not contain children columns.
         * ```typescript
         * let childrenColumns =  this.column.allChildren;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns the children columns collection.
         * Returns an empty array if the column does not contain children columns.
         * ```typescript
         * let childrenColumns =  this.column.allChildren;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "level", {
        /**
         * Returns the level of the column in a column group.
         * Returns `0` if the column doesn't have a `parent`.
         * ```typescript
         * let columnLevel =  this.column.level;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns the level of the column in a column group.
         * Returns `0` if the column doesn't have a `parent`.
         * ```typescript
         * let columnLevel =  this.column.level;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var ptr = this.parent;
            /** @type {?} */
            var lvl = 0;
            while (ptr) {
                lvl++;
                ptr = ptr.parent;
            }
            return lvl;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "isLastPinned", {
        get: /**
         * @return {?}
         */
        function () {
            return this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1] === this;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "gridRowSpan", {
        get: /**
         * @return {?}
         */
        function () {
            return this.rowEnd && this.rowStart ? this.rowEnd - this.rowStart : 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "gridColumnSpan", {
        get: /**
         * @return {?}
         */
        function () {
            return this.colEnd && this.colStart ? this.colEnd - this.colStart : 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "filteringExpressionsTree", {
        /**
         * Returns the filteringExpressionsTree of the column.
         * ```typescript
         * let tree =  this.column.filteringExpressionsTree;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns the filteringExpressionsTree of the column.
         * ```typescript
         * let tree =  this.column.filteringExpressionsTree;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (this.grid.filteringExpressionsTree.find(this.field)));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "isPrimaryColumn", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @protected
         * @return {?}
         */
        function () {
            return this.field !== undefined && this.grid !== undefined && this.field === this.grid.primaryKey;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxColumnComponent.prototype.resetCaches = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        this._vIndex = NaN;
        if (this.grid) {
            this.cacheCalcWidth();
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxColumnComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.cellTemplate) {
            this._bodyTemplate = this.cellTemplate.template;
        }
        if (this.headTemplate && this.headTemplate.length) {
            this._headerTemplate = this.headTemplate.toArray()[0].template;
        }
        if (this.editorTemplate) {
            this._inlineEditorTemplate = this.editorTemplate.template;
        }
        if (this.filterCellTemplateDirective) {
            this._filterCellTemplate = this.filterCellTemplateDirective.template;
        }
        if (!this.summaries) {
            switch (this.dataType) {
                case DataType.String:
                case DataType.Boolean:
                    this.summaries = IgxSummaryOperand;
                    break;
                case DataType.Number:
                    this.summaries = IgxNumberSummaryOperand;
                    break;
                case DataType.Date:
                    this.summaries = IgxDateSummaryOperand;
                    break;
                default:
                    this.summaries = IgxSummaryOperand;
                    break;
            }
        }
        if (!this.filters) {
            switch (this.dataType) {
                case DataType.Boolean:
                    this.filters = IgxBooleanFilteringOperand.instance();
                    break;
                case DataType.Number:
                    this.filters = IgxNumberFilteringOperand.instance();
                    break;
                case DataType.Date:
                    this.filters = IgxDateFilteringOperand.instance();
                    break;
                case DataType.String:
                default:
                    this.filters = IgxStringFilteringOperand.instance();
                    break;
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} isRow
     * @param {?} isIE
     * @return {?}
     */
    IgxColumnComponent.prototype.getGridTemplate = /**
     * @hidden
     * @param {?} isRow
     * @param {?} isIE
     * @return {?}
     */
    function (isRow, isIE) {
        if (isRow) {
            /** @type {?} */
            var rowsCount = this.grid.multiRowLayoutRowSize;
            return isIE ?
                "(1fr)[" + rowsCount + "]" :
                "repeat(" + rowsCount + ",1fr)";
        }
        else {
            return this.getColumnSizesString(this.children);
        }
    };
    /**
     * @param {?} children
     * @return {?}
     */
    IgxColumnComponent.prototype.getInitialChildColumnSizes = /**
     * @param {?} children
     * @return {?}
     */
    function (children) {
        var _this = this;
        /** @type {?} */
        var columnSizes = [];
        // find the smallest col spans
        children.forEach(function (col) {
            if (!col.colStart) {
                return;
            }
            /** @type {?} */
            var newWidthSet = col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            /** @type {?} */
            var newSpanSmaller = columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].colSpan > col.gridColumnSpan;
            /** @type {?} */
            var bothWidthsSet = col.widthSetByUser && columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].widthSetByUser;
            /** @type {?} */
            var bothWidthsNotSet = !col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            if (columnSizes[col.colStart - 1] === undefined) {
                // If nothing is defined yet take any column at first
                // We use colEnd to know where the column actually ends, because not always it starts where we have it set in columnSizes.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || _this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (newWidthSet || (newSpanSmaller && ((bothWidthsSet) || (bothWidthsNotSet)))) {
                // If a column is set already it should either not have width defined or have width with bigger span than the new one.
                /**
                 *  If replaced column has bigger span, we want to fill the remaining columns
                 *  that the replacing column does not fill with the old one.
                 **/
                if (bothWidthsSet && newSpanSmaller) {
                    // Start from where the new column set would end and apply the old column to the rest depending on how much it spans.
                    // We have not yet replaced it so we can use it directly from the columnSizes collection.
                    // This is where colEnd is used because the colStart of the old column is not actually i + 1.
                    for (var i = col.colStart - 1 + col.gridColumnSpan; i < columnSizes[col.colStart - 1].colEnd - 1; i++) {
                        if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                            columnSizes[i] = columnSizes[col.colStart - 1];
                        }
                        else {
                            break;
                        }
                    }
                }
                // Replace the old column with the new one.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || _this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (bothWidthsSet && columnSizes[col.colStart - 1].colSpan < col.gridColumnSpan) {
                // If the column already in the columnSizes has smaller span, we still need to fill any empty places with the current col.
                // Start from where the smaller column set would end and apply the bigger column to the rest depending on how much it spans.
                // Since here we do not have it in columnSizes we set it as a new column keeping the same colSpan.
                for (var i = col.colStart - 1 + columnSizes[col.colStart - 1].colSpan; i < col.colStart - 1 + col.gridColumnSpan; i++) {
                    if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                        columnSizes[i] = {
                            ref: col,
                            width: col.widthSetByUser || _this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                            colSpan: col.gridColumnSpan,
                            colEnd: col.colStart + col.gridColumnSpan,
                            widthSetByUser: col.widthSetByUser
                        };
                    }
                    else {
                        break;
                    }
                }
            }
        });
        // Flatten columnSizes so there are not columns with colSpan > 1
        for (var i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && columnSizes[i].colSpan > 1) {
                /** @type {?} */
                var j = 1;
                // Replace all empty places depending on how much the current column spans starting from next col.
                for (; j < columnSizes[i].colSpan && i + j + 1 < columnSizes[i].colEnd; j++) {
                    if (columnSizes[i + j] &&
                        ((!columnSizes[i].width && columnSizes[i + j].width) ||
                            (!columnSizes[i].width && !columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan) ||
                            (!!columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan))) {
                        // If we reach an already defined column that has width and the current doesn't have or
                        // if the reached column has bigger colSpan we stop.
                        break;
                    }
                    else {
                        /** @type {?} */
                        var width = columnSizes[i].widthSetByUser ?
                            columnSizes[i].width / columnSizes[i].colSpan :
                            columnSizes[i].width;
                        columnSizes[i + j] = {
                            ref: columnSizes[i].ref,
                            width: width,
                            colSpan: 1,
                            colEnd: columnSizes[i].colEnd,
                            widthSetByUser: columnSizes[i].widthSetByUser
                        };
                    }
                }
                // Update the current column width so it is divided between all columns it spans and set it to 1.
                columnSizes[i].width = columnSizes[i].widthSetByUser ?
                    columnSizes[i].width / columnSizes[i].colSpan :
                    columnSizes[i].width;
                columnSizes[i].colSpan = 1;
                // Update the index based on how much we have replaced. Subtract 1 because we started from 1.
                i += j - 1;
            }
        }
        return columnSizes;
    };
    /**
     * @param {?} children
     * @return {?}
     */
    IgxColumnComponent.prototype.getFilledChildColumnSizes = /**
     * @param {?} children
     * @return {?}
     */
    function (children) {
        /** @type {?} */
        var columnSizes = this.getInitialChildColumnSizes(children);
        // fill the gaps if there are any
        /** @type {?} */
        var result = [];
        for (var i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && !!columnSizes[i].width) {
                result.push(columnSizes[i].width + 'px');
            }
            else {
                result.push(parseInt(this.grid.getPossibleColumnWidth(), 10) + 'px');
            }
        }
        return result;
    };
    /**
     * @protected
     * @param {?} children
     * @return {?}
     */
    IgxColumnComponent.prototype.getColumnSizesString = /**
     * @protected
     * @param {?} children
     * @return {?}
     */
    function (children) {
        /** @type {?} */
        var res = this.getFilledChildColumnSizes(children);
        return res.join(' ');
    };
    /**
     * @return {?}
     */
    IgxColumnComponent.prototype.getResizableColUnderEnd = /**
     * @return {?}
     */
    function () {
        if (this.columnLayout || !this.columnLayoutChild || this.columnGroup) {
            return [{ target: this, spanUsed: 1 }];
        }
        /** @type {?} */
        var columnSized = this.getInitialChildColumnSizes(this.parent.children);
        /** @type {?} */
        var targets = [];
        /** @type {?} */
        var colEnd = this.colEnd ? this.colEnd : this.colStart + 1;
        for (var i = 0; i < columnSized.length; i++) {
            if (this.colStart <= i + 1 && i + 1 < colEnd) {
                targets.push({ target: columnSized[i].ref, spanUsed: 1 });
            }
        }
        /** @type {?} */
        var targetsSquashed = [];
        for (var j = 0; j < targets.length; j++) {
            if (targetsSquashed.length && targetsSquashed[targetsSquashed.length - 1].target.field === targets[j].target.field) {
                targetsSquashed[targetsSquashed.length - 1].spanUsed++;
            }
            else {
                targetsSquashed.push(targets[j]);
            }
        }
        return targetsSquashed;
    };
    /**
     * Pins the column at the provided index in the pinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
     * Column cannot be pinned if:
     * - Is already pinned
     * - index argument is out of range
     * - The pinned area exceeds 80% of the grid width
     * ```typescript
     * let success = this.column.pin();
     * ```
     * @memberof IgxColumnComponent
     */
    /**
     * Pins the column at the provided index in the pinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
     * Column cannot be pinned if:
     * - Is already pinned
     * - index argument is out of range
     * - The pinned area exceeds 80% of the grid width
     * ```typescript
     * let success = this.column.pin();
     * ```
     * \@memberof IgxColumnComponent
     * @param {?=} index
     * @return {?}
     */
    IgxColumnComponent.prototype.pin = /**
     * Pins the column at the provided index in the pinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
     * Column cannot be pinned if:
     * - Is already pinned
     * - index argument is out of range
     * - The pinned area exceeds 80% of the grid width
     * ```typescript
     * let success = this.column.pin();
     * ```
     * \@memberof IgxColumnComponent
     * @param {?=} index
     * @return {?}
     */
    function (index) {
        // TODO: Probably should the return type of the old functions
        // should be moved as a event parameter.
        if (this.grid) {
            this.grid.endEdit(true);
        }
        if (this._pinned) {
            return false;
        }
        if (this.parent && !this.parent.pinned) {
            return this.topLevelParent.pin(index);
        }
        /** @type {?} */
        var grid = ((/** @type {?} */ (this.grid)));
        /** @type {?} */
        var hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index >= grid.pinnedColumns.length)) {
            return false;
        }
        if (!this.parent && !this.pinnable) {
            return false;
        }
        this._pinned = true;
        this.pinnedChange.emit(this._pinned);
        this._unpinnedIndex = grid._unpinnedColumns.indexOf(this);
        index = index !== undefined ? index : grid._pinnedColumns.length;
        /** @type {?} */
        var targetColumn = grid._pinnedColumns[index];
        /** @type {?} */
        var args = { column: this, insertAtIndex: index, isPinned: true };
        grid.onColumnPinning.emit(args);
        if (grid._pinnedColumns.indexOf(this) === -1) {
            grid._pinnedColumns.splice(args.insertAtIndex, 0, this);
            if (grid._unpinnedColumns.indexOf(this) !== -1) {
                grid._unpinnedColumns.splice(grid._unpinnedColumns.indexOf(this), 1);
            }
        }
        if (hasIndex) {
            grid._moveColumns(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(function (child) { return child.pin(); });
            grid.reinitPinStates();
        }
        grid.resetCaches();
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(function (x) { return x.columnLayout; }).forEach(function (x) { return x.populateVisibleIndexes(); });
        }
        this.grid.filteringService.refreshExpressions();
        // this.grid.refreshSearch(true);
        return true;
    };
    /**
     * Unpins the column and place it at the provided index in the unpinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
     * Column cannot be unpinned if:
     * - Is already unpinned
     * - index argument is out of range
     * ```typescript
     * let success = this.column.unpin();
     * ```
     * @memberof IgxColumnComponent
     */
    /**
     * Unpins the column and place it at the provided index in the unpinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
     * Column cannot be unpinned if:
     * - Is already unpinned
     * - index argument is out of range
     * ```typescript
     * let success = this.column.unpin();
     * ```
     * \@memberof IgxColumnComponent
     * @param {?=} index
     * @return {?}
     */
    IgxColumnComponent.prototype.unpin = /**
     * Unpins the column and place it at the provided index in the unpinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
     * Column cannot be unpinned if:
     * - Is already unpinned
     * - index argument is out of range
     * ```typescript
     * let success = this.column.unpin();
     * ```
     * \@memberof IgxColumnComponent
     * @param {?=} index
     * @return {?}
     */
    function (index) {
        if (this.grid) {
            this.grid.endEdit(true);
        }
        if (!this._pinned) {
            return false;
        }
        if (this.parent && this.parent.pinned) {
            return this.topLevelParent.unpin(index);
        }
        /** @type {?} */
        var grid = ((/** @type {?} */ (this.grid)));
        /** @type {?} */
        var hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index >= grid._unpinnedColumns.length)) {
            return false;
        }
        index = (index !== undefined ? index :
            this._unpinnedIndex !== undefined ? this._unpinnedIndex : this.index);
        this._pinned = false;
        this.pinnedChange.emit(this._pinned);
        /** @type {?} */
        var targetColumn = grid._unpinnedColumns[index];
        grid._unpinnedColumns.splice(index, 0, this);
        if (grid._pinnedColumns.indexOf(this) !== -1) {
            grid._pinnedColumns.splice(grid._pinnedColumns.indexOf(this), 1);
        }
        if (hasIndex) {
            grid._moveColumns(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(function (child) { return child.unpin(); });
        }
        grid.reinitPinStates();
        grid.resetCaches();
        /** @type {?} */
        var insertAtIndex = grid._unpinnedColumns.indexOf(this);
        /** @type {?} */
        var args = { column: this, insertAtIndex: insertAtIndex, isPinned: false };
        grid.onColumnPinning.emit(args);
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(function (x) { return x.columnLayout; }).forEach(function (x) { return x.populateVisibleIndexes(); });
        }
        this.grid.filteringService.refreshExpressions();
        // this.grid.refreshSearch(true);
        return true;
    };
    Object.defineProperty(IgxColumnComponent.prototype, "topLevelParent", {
        /**
         * Returns a reference to the top level parent column.
         * ```typescript
         * let topLevelParent =  this.column.topLevelParent;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a reference to the top level parent column.
         * ```typescript
         * let topLevelParent =  this.column.topLevelParent;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var parent = this.parent;
            while (parent && parent.parent) {
                parent = parent.parent;
            }
            return parent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "headerCell", {
        /**
         * Returns a reference to the header of the column.
         * ```typescript
         * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
         * let headerCell = column.headerCell;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a reference to the header of the column.
         * ```typescript
         * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
         * let headerCell = column.headerCell;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            var _this = this;
            return this.grid.headerCellList.find(function (header) { return header.column === _this; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "filterCell", {
        /**
        * Returns a reference to the filter cell of the column.
        * ```typescript
        * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
        * let filterell = column.filterell;
        * ```
        * @memberof IgxColumnComponent
        */
        get: /**
         * Returns a reference to the filter cell of the column.
         * ```typescript
         * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
         * let filterell = column.filterell;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            var _this = this;
            return this.grid.filterCellList.find(function (filterCell) { return filterCell.column === _this; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "headerGroup", {
        /**
         * Returns a reference to the header group of the column.
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a reference to the header group of the column.
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            var _this = this;
            return this.grid.headerGroupsList.find(function (headerGroup) { return headerGroup.column === _this; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Autosize the column to the longest currently visible cell value, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * column.autosize();
     * ```
     * @memberof IgxColumnComponent
     */
    /**
     * Autosize the column to the longest currently visible cell value, including the header cell.
     * ```typescript
     * \@ViewChild('grid') grid: IgxGridComponent;
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * column.autosize();
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    IgxColumnComponent.prototype.autosize = /**
     * Autosize the column to the longest currently visible cell value, including the header cell.
     * ```typescript
     * \@ViewChild('grid') grid: IgxGridComponent;
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * column.autosize();
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    function () {
        if (!this.columnGroup) {
            this.width = this.getLargestCellWidth();
            this.grid.reflow();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxColumnComponent.prototype.getCalcWidth = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this._calcWidth !== null && !isNaN(this.calcPixelWidth)) {
            return this._calcWidth;
        }
        this.cacheCalcWidth();
        return this._calcWidth;
    };
    /**
     * @hidden
     * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let size = column.getLargestCellWidth();
     * ```
     * @memberof IgxColumnComponent
     */
    /**
     * @hidden
     * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
     * ```typescript
     * \@ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let size = column.getLargestCellWidth();
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    IgxColumnComponent.prototype.getLargestCellWidth = /**
     * @hidden
     * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
     * ```typescript
     * \@ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let size = column.getLargestCellWidth();
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    function () {
        /** @type {?} */
        var range = this.grid.document.createRange();
        /** @type {?} */
        var largest = new Map();
        if (this.cells.length > 0) {
            /** @type {?} */
            var cellsContentWidths_1 = [];
            if (this.cells[0].nativeElement.children.length > 0) {
                this.cells.forEach(function (cell) { return cellsContentWidths_1.push(cell.calculateSizeToFit(range)); });
            }
            else {
                cellsContentWidths_1 = this.cells.map(function (cell) { return getNodeSizeViaRange(range, cell.nativeElement); });
            }
            /** @type {?} */
            var index = cellsContentWidths_1.indexOf(Math.max.apply(Math, tslib_1.__spread(cellsContentWidths_1)));
            /** @type {?} */
            var cellStyle = this.grid.document.defaultView.getComputedStyle(this.cells[index].nativeElement);
            /** @type {?} */
            var cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight) +
                parseFloat(cellStyle.borderRightWidth);
            largest.set(Math.max.apply(Math, tslib_1.__spread(cellsContentWidths_1)), cellPadding);
        }
        if (this.headerCell) {
            /** @type {?} */
            var headerCell = void 0;
            if (this.headerTemplate && this.headerCell.elementRef.nativeElement.children[0].children.length > 0) {
                headerCell = Math.max.apply(Math, tslib_1.__spread(Array.from(this.headerCell.elementRef.nativeElement.children[0].children)
                    .map(function (child) { return getNodeSizeViaRange(range, child); })));
            }
            else {
                headerCell = getNodeSizeViaRange(range, this.headerCell.elementRef.nativeElement.children[0]);
            }
            if (this.sortable || this.filterable) {
                headerCell += this.headerCell.elementRef.nativeElement.children[1].getBoundingClientRect().width;
            }
            /** @type {?} */
            var headerStyle = this.grid.document.defaultView.getComputedStyle(this.headerCell.elementRef.nativeElement);
            /** @type {?} */
            var headerPadding = parseFloat(headerStyle.paddingLeft) + parseFloat(headerStyle.paddingRight) +
                parseFloat(headerStyle.borderRightWidth);
            largest.set(headerCell, headerPadding);
        }
        /** @type {?} */
        var largestCell = Math.max.apply(Math, tslib_1.__spread(Array.from(largest.keys())));
        /** @type {?} */
        var width = Math.ceil(largestCell + largest.get(largestCell));
        if (Number.isNaN(width)) {
            return this.width;
        }
        else {
            return width + 'px';
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxColumnComponent.prototype.getCellWidth = /**
     * @hidden
     * @return {?}
     */
    function () {
        /** @type {?} */
        var colWidth = this.width;
        /** @type {?} */
        var isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (this.columnLayoutChild) {
            return '';
        }
        if (colWidth && !isPercentageWidth) {
            /** @type {?} */
            var cellWidth = colWidth;
            if (typeof cellWidth !== 'string' || cellWidth.endsWith('px') === false) {
                cellWidth += 'px';
            }
            return cellWidth;
        }
        else {
            return colWidth;
        }
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @protected
     * @return {?}
     */
    IgxColumnComponent.prototype.cacheCalcWidth = /**
     * @hidden
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var grid = this.gridAPI.grid;
        /** @type {?} */
        var colWidth = this.width;
        /** @type {?} */
        var isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (isPercentageWidth) {
            this._calcWidth = parseInt(colWidth, 10) / 100 * (grid.calcWidth - grid.featureColumnsWidth);
        }
        else if (!colWidth) {
            // no width
            this._calcWidth = this.defaultWidth || grid.getPossibleColumnWidth();
        }
        else {
            this._calcWidth = this.width;
        }
        this.calcPixelWidth = parseInt(this._calcWidth, 10);
    };
    Object.defineProperty(IgxColumnComponent.prototype, "pinnable", {
        /**
         *@hidden
        */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var gridUnpinnedWidth = ((/** @type {?} */ (this.grid))).getUnpinnedWidth(true);
            /** @type {?} */
            var elementWidth = this.parent ? parseInt(this.topLevelParent.width, 10) : parseInt(this.width, 10);
            return ((/** @type {?} */ (this.grid)))._init || !((gridUnpinnedWidth - elementWidth) < this.grid.unpinnedAreaMinWidth);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxColumnComponent.prototype.populateVisibleIndexes = /**
     * @hidden
     * @return {?}
     */
    function () { };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxColumnComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.destroy$.next(true);
        this.destroy$.complete();
    };
    IgxColumnComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-column',
                    template: ""
                }] }
    ];
    /** @nocollapse */
    IgxColumnComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: ChangeDetectorRef },
        { type: IgxRowIslandAPIService }
    ]; };
    IgxColumnComponent.propDecorators = {
        field: [{ type: Input }],
        header: [{ type: Input }],
        sortable: [{ type: Input }],
        groupable: [{ type: Input }],
        editable: [{ type: Input }],
        filterable: [{ type: Input }],
        resizable: [{ type: Input }],
        hasSummary: [{ type: Input }],
        hidden: [{ type: Input }],
        hiddenChange: [{ type: Output }],
        disableHiding: [{ type: Input }],
        disablePinning: [{ type: Input }],
        movable: [{ type: Input }],
        width: [{ type: Input }],
        widthChange: [{ type: Output }],
        maxWidth: [{ type: Input }],
        minWidth: [{ type: Input }],
        headerClasses: [{ type: Input }],
        headerGroupClasses: [{ type: Input }],
        cellClasses: [{ type: Input }],
        cellStyles: [{ type: Input }],
        formatter: [{ type: Input }],
        filteringIgnoreCase: [{ type: Input }],
        sortingIgnoreCase: [{ type: Input }],
        dataType: [{ type: Input }],
        pinned: [{ type: Input }],
        pinnedChange: [{ type: Output }],
        summaries: [{ type: Input }],
        searchable: [{ type: Input }],
        filters: [{ type: Input }],
        sortStrategy: [{ type: Input }],
        groupingComparer: [{ type: Input }],
        bodyTemplate: [{ type: Input, args: ['cellTemplate',] }],
        headerTemplate: [{ type: Input }],
        inlineEditorTemplate: [{ type: Input, args: ['cellEditorTemplate',] }],
        filterCellTemplate: [{ type: Input, args: ['filterCellTemplate',] }],
        rowEnd: [{ type: Input }],
        colEnd: [{ type: Input }],
        rowStart: [{ type: Input }],
        colStart: [{ type: Input }],
        cellTemplate: [{ type: ContentChild, args: [IgxCellTemplateDirective, { read: IgxCellTemplateDirective, static: false },] }],
        headTemplate: [{ type: ContentChildren, args: [IgxCellHeaderTemplateDirective, { read: IgxCellHeaderTemplateDirective, descendants: false },] }],
        editorTemplate: [{ type: ContentChild, args: [IgxCellEditorTemplateDirective, { read: IgxCellEditorTemplateDirective, static: false },] }],
        filterCellTemplateDirective: [{ type: ContentChild, args: [IgxFilterCellTemplateDirective, { read: IgxFilterCellTemplateDirective, static: false },] }]
    };
    tslib_1.__decorate([
        notifyChanges(),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Object)
    ], IgxColumnComponent.prototype, "header", void 0);
    tslib_1.__decorate([
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Object)
    ], IgxColumnComponent.prototype, "sortable", void 0);
    tslib_1.__decorate([
        notifyChanges(true),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Object)
    ], IgxColumnComponent.prototype, "groupable", void 0);
    tslib_1.__decorate([
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], IgxColumnComponent.prototype, "editable", null);
    tslib_1.__decorate([
        notifyChanges(),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Object)
    ], IgxColumnComponent.prototype, "filterable", void 0);
    tslib_1.__decorate([
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Object)
    ], IgxColumnComponent.prototype, "resizable", void 0);
    tslib_1.__decorate([
        notifyChanges(true),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Object),
        tslib_1.__metadata("design:paramtypes", [Object])
    ], IgxColumnComponent.prototype, "hasSummary", null);
    tslib_1.__decorate([
        notifyChanges(true),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], IgxColumnComponent.prototype, "hidden", null);
    tslib_1.__decorate([
        notifyChanges(),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Object)
    ], IgxColumnComponent.prototype, "disableHiding", void 0);
    tslib_1.__decorate([
        notifyChanges(),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Object)
    ], IgxColumnComponent.prototype, "disablePinning", void 0);
    tslib_1.__decorate([
        WatchColumnChanges(),
        notifyChanges(),
        tslib_1.__metadata("design:type", Object)
    ], IgxColumnComponent.prototype, "movable", void 0);
    tslib_1.__decorate([
        notifyChanges(true),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", String),
        tslib_1.__metadata("design:paramtypes", [String])
    ], IgxColumnComponent.prototype, "width", null);
    tslib_1.__decorate([
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", String)
    ], IgxColumnComponent.prototype, "maxWidth", void 0);
    tslib_1.__decorate([
        notifyChanges(),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", String),
        tslib_1.__metadata("design:paramtypes", [String])
    ], IgxColumnComponent.prototype, "minWidth", null);
    tslib_1.__decorate([
        notifyChanges(),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Object)
    ], IgxColumnComponent.prototype, "headerClasses", void 0);
    tslib_1.__decorate([
        notifyChanges(),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Object)
    ], IgxColumnComponent.prototype, "headerGroupClasses", void 0);
    tslib_1.__decorate([
        notifyChanges(),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Object)
    ], IgxColumnComponent.prototype, "cellClasses", void 0);
    tslib_1.__decorate([
        notifyChanges(),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Object)
    ], IgxColumnComponent.prototype, "cellStyles", void 0);
    tslib_1.__decorate([
        notifyChanges(),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Function)
    ], IgxColumnComponent.prototype, "formatter", void 0);
    tslib_1.__decorate([
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Object)
    ], IgxColumnComponent.prototype, "filteringIgnoreCase", void 0);
    tslib_1.__decorate([
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Object)
    ], IgxColumnComponent.prototype, "sortingIgnoreCase", void 0);
    tslib_1.__decorate([
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], IgxColumnComponent.prototype, "pinned", null);
    tslib_1.__decorate([
        DeprecateProperty("The property is deprecated. Please, use `column.grid.id` instead."),
        tslib_1.__metadata("design:type", String)
    ], IgxColumnComponent.prototype, "gridID", void 0);
    tslib_1.__decorate([
        notifyChanges(true),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Object),
        tslib_1.__metadata("design:paramtypes", [Object])
    ], IgxColumnComponent.prototype, "summaries", null);
    tslib_1.__decorate([
        notifyChanges(),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", Object)
    ], IgxColumnComponent.prototype, "searchable", void 0);
    tslib_1.__decorate([
        notifyChanges(),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", TemplateRef),
        tslib_1.__metadata("design:paramtypes", [TemplateRef])
    ], IgxColumnComponent.prototype, "bodyTemplate", null);
    tslib_1.__decorate([
        notifyChanges(),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", TemplateRef),
        tslib_1.__metadata("design:paramtypes", [TemplateRef])
    ], IgxColumnComponent.prototype, "headerTemplate", null);
    tslib_1.__decorate([
        notifyChanges(),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", TemplateRef),
        tslib_1.__metadata("design:paramtypes", [TemplateRef])
    ], IgxColumnComponent.prototype, "inlineEditorTemplate", null);
    tslib_1.__decorate([
        notifyChanges(),
        WatchColumnChanges(),
        tslib_1.__metadata("design:type", TemplateRef),
        tslib_1.__metadata("design:paramtypes", [TemplateRef])
    ], IgxColumnComponent.prototype, "filterCellTemplate", null);
    return IgxColumnComponent;
}());
export { IgxColumnComponent };
if (false) {
    /**
     * Sets/gets the `field` value.
     * ```typescript
     * let columnField = this.column.field;
     * ```
     * ```html
     * <igx-column [field] = "'ID'"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.field;
    /**
     * Sets/gets the `header` value.
     * ```typescript
     * let columnHeader = this.column.header;
     * ```
     * ```html
     * <igx-column [header] = "'ID'"></igx-column>
     * ```
     *
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.header;
    /**
     * Sets/gets whether the column is sortable.
     * Default value is `false`.
     * ```typescript
     * let isSortable = this.column.sortable;
     * ```
     * ```html
     * <igx-column [sortable] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.sortable;
    /**
     * Sets/gets whether the column is groupable.
     * Default value is `false`.
     * ```typescript
     * let isGroupable = this.column.groupable;
     * ```
     * ```html
     * <igx-column [groupable] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.groupable;
    /**
     * Sets/gets whether the column is filterable.
     * Default value is `true`.
     * ```typescript
     * let isFilterable = this.column.filterable;
     * ```
     * ```html
     * <igx-column [filterable] = "false"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.filterable;
    /**
     * Sets/gets whether the column is resizable.
     * Default value is `false`.
     * ```typescript
     * let isResizable = this.column.resizable;
     * ```
     * ```html
     * <igx-column [resizable] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.resizable;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnComponent.prototype.hiddenChange;
    /**
     * Gets whether the hiding is disabled.
     * ```typescript
     * let isHidingDisabled =  this.column.disableHiding;
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.disableHiding;
    /**
     * Gets whether the pinning is disabled.
     * ```typescript
     * let isPinningDisabled =  this.column.disablePinning;
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.disablePinning;
    /**
     * Sets/gets whether the column is movable.
     * Default value is `false`.
     * ```typescript
     * let isMovable = this.column.movable;
     * ```
     * ```html
     * <igx-column [movable] = "true"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.movable;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnComponent.prototype.widthChange;
    /**
     * @type {?}
     * @private
     */
    IgxColumnComponent.prototype._calcWidth;
    /** @type {?} */
    IgxColumnComponent.prototype.calcPixelWidth;
    /**
     * Sets/gets the maximum `width` of the column.
     * ```typescript
     * let columnMaxWidth = this.column.width;
     * ```
     * ```html
     * <igx-column [maxWidth] = "'75%'"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.maxWidth;
    /**
     * Sets/gets the class selector of the column header.
     * ```typescript
     * let columnHeaderClass = this.column.headerClasses;
     * ```
     * ```html
     * <igx-column [headerClasses] = "'column-header'"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.headerClasses;
    /**
     * Sets/gets the class selector of the column group header.
     * ```typescript
     * let columnHeaderClass = this.column.headerGroupClasses;
     * ```
     * ```html
     * <igx-column [headerGroupClasses] = "'column-group-header'"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.headerGroupClasses;
    /**
     * Sets a conditional class selector of the column cells.
     * Accepts an object literal, containing key-value pairs,
     * where the key is the name of the CSS class, while the
     * value is either a callback function that returns a boolean,
     * or boolean, like so:
     * ```typescript
     * callback = (rowData, columnKey, cellValue, rowIndex) => { return rowData[columnKey] > 6; }
     * cellClasses = { 'className' : this.callback };
     * ```
     * ```html
     * <igx-column [cellClasses] = "cellClasses"></igx-column>
     * <igx-column [cellClasses] = "{'class1' : true }"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.cellClasses;
    /**
     * Sets conditional style properties on the column cells.
     * Similar to `ngStyle` it accepts an object literal where the keys are
     * the style properties and the value is the expression to be evaluated.
     * As with `cellClasses` it accepts a callback function.
     * ```typescript
     * styles = {
     *  background: 'royalblue',
     *  color: (rowData, columnKey, cellValue, rowIndex) => value.startsWith('Important') : 'red': 'inherit'
     * }
     * ```
     * ```html
     * <igx-column [cellStyles]="styles"></igx-column>
     * ```
     *
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.cellStyles;
    /**
     * When autogenerating columns, the formatter is used to format the display of the column data
     * without modifying the underlying bound values.
     *
     * In this example, we check to see if the column name is Salary, and then provide a method as the column formatter
     * to format the value into a currency string.
     *
     * ```typescript
     * onColumnInit(column: IgxColumnComponent) {
     *   if (column.field == "Salary") {
     *     column.formatter = (salary => this.format(salary));
     *   }
     * }
     *
     * format(value: number) : string {
     *   return formatCurrency(value, "en-us", "$");
     * }
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.formatter;
    /**
     * Sets/gets whether the column filtering should be case sensitive.
     * Default value is `true`.
     * ```typescript
     * let filteringIgnoreCase = this.column.filteringIgnoreCase;
     * ```
     * ```html
     * <igx-column [filteringIgnoreCase] = "false"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.filteringIgnoreCase;
    /**
     * Sets/gets whether the column sorting should be case sensitive.
     * Default value is `true`.
     * ```typescript
     * let sortingIgnoreCase = this.column.sortingIgnoreCase;
     * ```
     * ```html
     * <igx-column [sortingIgnoreCase] = "false"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.sortingIgnoreCase;
    /**
     * Sets/gets the data type of the column values.
     * Default value is `string`.
     * ```typescript
     * let columnDataType = this.column.dataType;
     * ```
     * ```html
     * <igx-column [dataType] = "'number'"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.dataType;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnComponent.prototype.pinnedChange;
    /**
     * @deprecated
     * Gets/Sets the `id` of the `igx-grid`.
     * ```typescript
     * let columnGridId = this.column.gridID;
     * ```
     * ```typescript
     * this.column.gridID = 'grid-1';
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.gridID;
    /**
     * Sets/gets whether the column is `searchable`.
     * Default value is `true`.
     * ```typescript
     * let isSearchable =  this.column.searchable';
     * ```
     * ```html
     *  <igx-column [searchable] = "false"></igx-column>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.searchable;
    /**
     * Row index where the current field should end.
     * The amount of rows between rowStart and rowEnd will determine the amount of spanning rows to that field
     * ```html
     * <igx-column-layout>
     *   <igx-column [rowEnd]="2" [rowStart]="1" [colStart]="1"></igx-column>
     * </igx-column-layout>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.rowEnd;
    /**
     * Column index where the current field should end.
     * The amount of columns between colStart and colEnd will determine the amount of spanning columns to that field
     * ```html
     * <igx-column-layout>
     *   <igx-column [colEnd]="3" [rowStart]="1" [colStart]="1"></igx-column>
     * </igx-column-layout>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.colEnd;
    /**
     * Row index from which the field is starting.
     * ```html
     * <igx-column-layout>
     *   <igx-column [rowStart]="1" [colStart]="1"></igx-column>
     * </igx-column-layout>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.rowStart;
    /**
     * Column index from which the field is starting.
     * ```html
     * <igx-column-layout>
     *   <igx-column [colStart]="1" [rowStart]="1"></igx-column>
     * </igx-column-layout>
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.colStart;
    /**
     * hidden
     * @type {?}
     */
    IgxColumnComponent.prototype.defaultWidth;
    /**
     * hidden
     * @type {?}
     */
    IgxColumnComponent.prototype.widthSetByUser;
    /**
     * Sets/gets the parent column.
     * ```typescript
     * let parentColumn = this.column.parent;
     * ```
     * ```typescript
     * this.column.parent = higherLevelColumn;
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.parent;
    /**
     * Sets/gets the children columns.
     * ```typescript
     * let columnChildren = this.column.children;
     * ```
     * ```typescript
     * this.column.children = childrenColumns;
     * ```
     * \@memberof IgxColumnComponent
     * @type {?}
     */
    IgxColumnComponent.prototype.children;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype.destroy$;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._unpinnedIndex;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._pinned;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._bodyTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._headerTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._inlineEditorTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._filterCellTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._summaries;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._filters;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._sortStrategy;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._groupingComparer;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._hidden;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._index;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._disablePinning;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._width;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._defaultMinWidth;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._hasSummary;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._editable;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype.cellTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype.headTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype.editorTemplate;
    /**
     * @type {?}
     * @protected
     */
    IgxColumnComponent.prototype._vIndex;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnComponent.prototype.filterCellTemplateDirective;
    /** @type {?} */
    IgxColumnComponent.prototype.gridAPI;
    /** @type {?} */
    IgxColumnComponent.prototype.cdr;
    /** @type {?} */
    IgxColumnComponent.prototype.rowIslandAPI;
}
var IgxColumnGroupComponent = /** @class */ (function (_super) {
    tslib_1.__extends(IgxColumnGroupComponent, _super);
    function IgxColumnGroupComponent(gridAPI, cdr, rowIslandAPI) {
        var _this = 
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        _super.call(this, gridAPI, cdr, rowIslandAPI) || this;
        _this.gridAPI = gridAPI;
        _this.cdr = cdr;
        _this.rowIslandAPI = rowIslandAPI;
        _this.children = new QueryList();
        /**
         * Sets/gets whether the column group is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.columnGroup.searchable;
         * ```
         * ```html
         *  <igx-column-group [searchable] = "false"></igx-column-group>
         * ```
         * \@memberof IgxColumnGroupComponent
         */
        _this.searchable = true;
        /**
         * @hidden
         */
        _this.hiddenChange = new EventEmitter();
        return _this;
    }
    Object.defineProperty(IgxColumnGroupComponent.prototype, "summaries", {
        /**
         * Gets the column group `summaries`.
         * ```typescript
         * let columnGroupSummaries = this.columnGroup.summaries;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Gets the column group `summaries`.
         * ```typescript
         * let columnGroupSummaries = this.columnGroup.summaries;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return this._summaries;
        },
        /**
         * Sets the column group `summaries`.
         * ```typescript
         * this.columnGroup.summaries = IgxNumberSummaryOperand;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        set: /**
         * Sets the column group `summaries`.
         * ```typescript
         * this.columnGroup.summaries = IgxNumberSummaryOperand;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @param {?} classRef
         * @return {?}
         */
        function (classRef) { },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "filters", {
        /**
         * Gets the column group `filters`.
         * ```typescript
         * let columnGroupFilters = this.columnGroup.filters;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Gets the column group `filters`.
         * ```typescript
         * let columnGroupFilters = this.columnGroup.filters;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return this._filters;
        },
        /**
         * Sets the column group `filters`.
         * ```typescript
         * this.columnGroup.filters = IgxStringFilteringOperand;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        set: /**
         * Sets the column group `filters`.
         * ```typescript
         * this.columnGroup.filters = IgxStringFilteringOperand;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @param {?} classRef
         * @return {?}
         */
        function (classRef) { },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "bodyTemplate", {
        /**
         * Returns a reference to the body template.
         * ```typescript
         * let bodyTemplate = this.columnGroup.bodyTemplate;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Returns a reference to the body template.
         * ```typescript
         * let bodyTemplate = this.columnGroup.bodyTemplate;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return this._bodyTemplate;
        },
        /**
         * @hidden
         */
        set: /**
         * @hidden
         * @param {?} template
         * @return {?}
         */
        function (template) { },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "inlineEditorTemplate", {
        /**
         * Returns a reference to the inline editor template.
         * ```typescript
         * let inlineEditorTemplate = this.columnGroup.inlineEditorTemplate;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Returns a reference to the inline editor template.
         * ```typescript
         * let inlineEditorTemplate = this.columnGroup.inlineEditorTemplate;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return this._inlineEditorTemplate;
        },
        /**
         * @hidden
         */
        set: /**
         * @hidden
         * @param {?} template
         * @return {?}
         */
        function (template) { },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "cells", {
        /**
         * Gets the column group cells.
         * ```typescript
         * let columnCells = this.columnGroup.cells;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Gets the column group cells.
         * ```typescript
         * let columnCells = this.columnGroup.cells;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "hidden", {
        /**
         * Gets whether the column group is hidden.
         * ```typescript
         * let isHidden = this.columnGroup.hidden;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Gets whether the column group is hidden.
         * ```typescript
         * let isHidden = this.columnGroup.hidden;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return this.allChildren.every(function (c) { return c.hidden; });
        },
        /**
         * Sets the column group hidden property.
         * ```html
         * <igx-column [hidden] = "true"></igx-column>
         * ```
         *
         * Two-way data binding
         * ```html
         * <igx-column [(hidden)] = "model.columns[0].isHidden"></igx-column>
         * ```
         * @memberof IgxColumnGroupComponent
         */
        set: /**
         * Sets the column group hidden property.
         * ```html
         * <igx-column [hidden] = "true"></igx-column>
         * ```
         *
         * Two-way data binding
         * ```html
         * <igx-column [(hidden)] = "model.columns[0].isHidden"></igx-column>
         * ```
         * \@memberof IgxColumnGroupComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._hidden = value;
            this.hiddenChange.emit(this._hidden);
            this.children.forEach(function (child) { return child.hidden = value; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxColumnGroupComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        /*
            @ContentChildren with descendants still returns the `parent`
            component in the query list.
        */
        if (this.headTemplate && this.headTemplate.length) {
            this._headerTemplate = this.headTemplate.toArray()[0].template;
        }
        this.children.reset(this.children.toArray().slice(1));
        this.children.forEach(function (child) {
            child.parent = _this;
        });
        /*
            TO DO: In Angular 9 this need to be removed, because the @ContentChildren will not return the `parent`
            component in the query list.
        */
        this.children.changes.pipe(takeUntil(this.destroy$))
            .subscribe(function (change) {
            if (change.first === _this) {
                _this.children.reset(_this.children.toArray().slice(1));
                _this.children.forEach(function (child) {
                    child.parent = _this;
                });
            }
        });
    };
    Object.defineProperty(IgxColumnGroupComponent.prototype, "allChildren", {
        /**
         * Returns the children columns collection.
         * ```typescript
         * let columns =  this.columnGroup.allChildren;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Returns the children columns collection.
         * ```typescript
         * let columns =  this.columnGroup.allChildren;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return flatten(this.children.toArray());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "columnGroup", {
        /**
         * Returns a boolean indicating if the column is a `ColumnGroup`.
         * ```typescript
         * let isColumnGroup =  this.columnGroup.columnGroup
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Returns a boolean indicating if the column is a `ColumnGroup`.
         * ```typescript
         * let isColumnGroup =  this.columnGroup.columnGroup
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "columnLayout", {
        /**
         * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
         * ```typescript
         * let columnGroup =  this.column.columnGroup;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
         * ```typescript
         * let columnGroup =  this.column.columnGroup;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "width", {
        /**
         * Gets the width of the column group.
         * ```typescript
         * let columnGroupWidth = this.columnGroup.width;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Gets the width of the column group.
         * ```typescript
         * let columnGroupWidth = this.columnGroup.width;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var isChildrenWidthInPercent = false;
            /** @type {?} */
            var width;
            width = "" + this.children.reduce(function (acc, val) {
                if (val.hidden) {
                    return acc;
                }
                if (typeof val.width === 'string' && val.width.indexOf('%') !== -1) {
                    isChildrenWidthInPercent = true;
                }
                return acc + parseInt(val.width, 10);
            }, 0);
            return isChildrenWidthInPercent ? width + '%' : width;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) { },
        enumerable: true,
        configurable: true
    });
    IgxColumnGroupComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [{ provide: IgxColumnComponent, useExisting: forwardRef(function () { return IgxColumnGroupComponent; }) }],
                    selector: 'igx-column-group',
                    template: ""
                }] }
    ];
    /** @nocollapse */
    IgxColumnGroupComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: ChangeDetectorRef },
        { type: IgxRowIslandAPIService }
    ]; };
    IgxColumnGroupComponent.propDecorators = {
        children: [{ type: ContentChildren, args: [IgxColumnComponent, { read: IgxColumnComponent },] }],
        summaries: [{ type: Input }],
        searchable: [{ type: Input }],
        filters: [{ type: Input }],
        hidden: [{ type: Input }],
        hiddenChange: [{ type: Output }]
    };
    return IgxColumnGroupComponent;
}(IgxColumnComponent));
export { IgxColumnGroupComponent };
if (false) {
    /** @type {?} */
    IgxColumnGroupComponent.prototype.children;
    /**
     * Sets/gets whether the column group is `searchable`.
     * Default value is `true`.
     * ```typescript
     * let isSearchable =  this.columnGroup.searchable;
     * ```
     * ```html
     *  <igx-column-group [searchable] = "false"></igx-column-group>
     * ```
     * \@memberof IgxColumnGroupComponent
     * @type {?}
     */
    IgxColumnGroupComponent.prototype.searchable;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnGroupComponent.prototype.hiddenChange;
    /** @type {?} */
    IgxColumnGroupComponent.prototype.gridAPI;
    /** @type {?} */
    IgxColumnGroupComponent.prototype.cdr;
    /** @type {?} */
    IgxColumnGroupComponent.prototype.rowIslandAPI;
}
var IgxColumnLayoutComponent = /** @class */ (function (_super) {
    tslib_1.__extends(IgxColumnLayoutComponent, _super);
    function IgxColumnLayoutComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.childrenVisibleIndexes = [];
        return _this;
    }
    Object.defineProperty(IgxColumnLayoutComponent.prototype, "width", {
        /**
         * Gets the width of the column layout.
         * ```typescript
         * let columnGroupWidth = this.columnGroup.width;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Gets the width of the column layout.
         * ```typescript
         * let columnGroupWidth = this.columnGroup.width;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var width = this.getFilledChildColumnSizes(this.children).reduce(function (acc, val) { return acc + parseInt(val, 10); }, 0);
            return width;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) { },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnLayoutComponent.prototype, "columnLayout", {
        get: /**
         * @return {?}
         */
        function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxColumnLayoutComponent.prototype.getCalcWidth = /**
     * @hidden
     * @return {?}
     */
    function () {
        /** @type {?} */
        var borderWidth = 0;
        if (this.headerGroup && this.headerGroup.hasLastPinnedChildColumn) {
            /** @type {?} */
            var headerStyles = this.grid.document.defaultView.getComputedStyle(this.headerGroup.element.nativeElement.children[0]);
            borderWidth = parseInt(headerStyles.borderRightWidth, 10);
        }
        return _super.prototype.getCalcWidth.call(this) + borderWidth;
    };
    Object.defineProperty(IgxColumnLayoutComponent.prototype, "visibleIndex", {
        /**
         * Gets the column visible index.
         * If the column is not visible, returns `-1`.
         * ```typescript
         * let visibleColumnIndex =  this.column.visibleIndex;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the column visible index.
         * If the column is not visible, returns `-1`.
         * ```typescript
         * let visibleColumnIndex =  this.column.visibleIndex;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            if (!isNaN(this._vIndex)) {
                return this._vIndex;
            }
            /** @type {?} */
            var unpinnedColumns = this.grid.unpinnedColumns.filter(function (c) { return c.columnLayout && !c.hidden; });
            /** @type {?} */
            var pinnedColumns = this.grid.pinnedColumns.filter(function (c) { return c.columnLayout && !c.hidden; });
            /** @type {?} */
            var vIndex = -1;
            if (!this.pinned) {
                /** @type {?} */
                var indexInCollection = unpinnedColumns.indexOf(this);
                vIndex = indexInCollection === -1 ? -1 : pinnedColumns.length + indexInCollection;
            }
            else {
                vIndex = pinnedColumns.indexOf(this);
            }
            this._vIndex = vIndex;
            return vIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnLayoutComponent.prototype, "hidden", {
        /*
         * Gets whether the column layout is hidden.
         * ```typescript
         * let isHidden = this.columnGroup.hidden;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /*
             * Gets whether the column layout is hidden.
             * ```typescript
             * let isHidden = this.columnGroup.hidden;
             * ```
             * @memberof IgxColumnGroupComponent
             */
        /**
         * @return {?}
         */
        function () {
            return this._hidden;
        },
        /**
         * Sets the column layout hidden property.
         * ```typescript
         * <igx-column-layout [hidden] = "true"></igx-column->
         * ```
         * @memberof IgxColumnGroupComponent
         */
        set: /**
         * Sets the column layout hidden property.
         * ```typescript
         * <igx-column-layout [hidden] = "true"></igx-column->
         * ```
         * \@memberof IgxColumnGroupComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._hidden = value;
            this.children.forEach(function (child) { return child.hidden = value; });
            if (this.grid && this.grid.columns && this.grid.columns.length > 0) {
                // reset indexes in case columns are hidden/shown runtime
                this.grid.columns.filter(function (x) { return x.columnGroup; }).forEach(function (x) { return x.populateVisibleIndexes(); });
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
    */
    /**
     * @hidden
     * @return {?}
     */
    IgxColumnLayoutComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngAfterContentInit.call(this);
        if (!this.hidden) {
            this.hidden = this.allChildren.some(function (x) { return x.hidden; });
        }
        else {
            this.children.forEach(function (child) { return child.hidden = _this.hidden; });
        }
        this.children.forEach(function (child) {
            child.movable = false;
        });
    };
    Object.defineProperty(IgxColumnLayoutComponent.prototype, "hasLastPinnedChildColumn", {
        /*
         * Gets whether the group contains the last pinned child column of the column layout.
         * ```typescript
         * let columsHasLastPinned = this.columnLayout.hasLastPinnedChildColumn;
         * ```
         * @memberof IgxColumnLayoutComponent
         */
        get: /*
             * Gets whether the group contains the last pinned child column of the column layout.
             * ```typescript
             * let columsHasLastPinned = this.columnLayout.hasLastPinnedChildColumn;
             * ```
             * @memberof IgxColumnLayoutComponent
             */
        /**
         * @return {?}
         */
        function () {
            return this.children.some(function (child) { return child.isLastPinned; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
    */
    /**
     * @hidden
     * @return {?}
     */
    IgxColumnLayoutComponent.prototype.populateVisibleIndexes = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this.childrenVisibleIndexes = [];
        /** @type {?} */
        var grid = this.gridAPI.grid;
        /** @type {?} */
        var columns = grid && grid.pinnedColumns && grid.unpinnedColumns ? grid.pinnedColumns.concat(grid.unpinnedColumns) : [];
        /** @type {?} */
        var orderedCols = columns
            .filter(function (x) { return !x.columnGroup && !x.hidden; })
            .sort(function (a, b) { return a.rowStart - b.rowStart || columns.indexOf(a.parent) - columns.indexOf(b.parent) || a.colStart - b.colStart; });
        this.children.forEach(function (child) {
            /** @type {?} */
            var rs = child.rowStart || 1;
            /** @type {?} */
            var vIndex = 0;
            // filter out all cols with larger rowStart
            /** @type {?} */
            var cols = orderedCols.filter(function (c) {
                return !c.columnGroup && (c.rowStart || 1) <= rs;
            });
            vIndex = cols.indexOf(child);
            _this.childrenVisibleIndexes.push({ column: child, index: vIndex });
        });
    };
    IgxColumnLayoutComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [{ provide: IgxColumnComponent, useExisting: forwardRef(function () { return IgxColumnLayoutComponent; }) }],
                    selector: 'igx-column-layout',
                    template: ""
                }] }
    ];
    IgxColumnLayoutComponent.propDecorators = {
        hidden: [{ type: Input }]
    };
    return IgxColumnLayoutComponent;
}(IgxColumnGroupComponent));
export { IgxColumnLayoutComponent };
if (false) {
    /** @type {?} */
    IgxColumnLayoutComponent.prototype.childrenVisibleIndexes;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sdW1uLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvY29sdW1uLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFFSCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxZQUFZLEVBQ1osZUFBZSxFQUNmLEtBQUssRUFDTCxTQUFTLEVBQ1QsV0FBVyxFQUNYLFVBQVUsRUFFVixNQUFNLEVBQ04sWUFBWSxFQUNmLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3JELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDRDQUE0QyxDQUFDO0FBQ3BGLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUN4RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFbkQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLHVCQUF1QixFQUFFLGlCQUFpQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDN0csT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRWxELE9BQU8sRUFBRSxzQkFBc0IsRUFBb0IsTUFBTSxxQ0FBcUMsQ0FBQztBQUMvRixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsT0FBTyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdELE9BQU8sRUFDSCwwQkFBMEIsRUFDMUIseUJBQXlCLEVBQ3pCLHVCQUF1QixFQUN2Qix5QkFBeUIsRUFDekIsbUJBQW1CLEVBQ3RCLE1BQU0sd0NBQXdDLENBQUM7QUFLaEQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFFaEUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3hELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFB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LENBQUMsQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRTtZQUF6QyxDQUF5QyxDQUFDO1lBQzlDLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzdCLEtBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZFLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQzs7Z0JBN0lKLFNBQVMsU0FBQztvQkFDUCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtvQkFDL0MsU0FBUyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsV0FBVyxFQUFFLFVBQVUsQ0FBQyxjQUFNLE9BQUEsd0JBQXdCLEVBQXhCLENBQXdCLENBQUMsRUFBRSxDQUFDO29CQUNyRyxRQUFRLEVBQUUsbUJBQW1CO29CQUM3QixRQUFRLEVBQUUsRUFBRTtpQkFDZjs7O3lCQXFFSSxLQUFLOztJQW9FViwrQkFBQztDQUFBLEFBOUlELENBTThDLHVCQUF1QixHQXdJcEU7U0F4SVksd0JBQXdCOzs7SUFDakMsMERBQW1DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgQ29udGVudENoaWxkcmVuLFxuICAgIElucHV0LFxuICAgIFF1ZXJ5TGlzdCxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBmb3J3YXJkUmVmLFxuICAgIE9uRGVzdHJveSxcbiAgICBPdXRwdXQsXG4gICAgRXZlbnRFbWl0dGVyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgV2F0Y2hDb2x1bW5DaGFuZ2VzIH0gZnJvbSAnLi93YXRjaC1jaGFuZ2VzJztcbmltcG9ydCB7IElneFJvd0lzbGFuZEFQSVNlcnZpY2UgfSBmcm9tICcuL2hpZXJhcmNoaWNhbC1ncmlkL3Jvdy1pc2xhbmQtYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi9kYXRhLW9wZXJhdGlvbnMvZGF0YS11dGlsJztcbmltcG9ydCB7IEdyaWRCYXNlQVBJU2VydmljZSB9IGZyb20gJy4vYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZENlbGxDb21wb25lbnQgfSBmcm9tICcuL2NlbGwuY29tcG9uZW50JztcbmltcG9ydCB7IElneERhdGVTdW1tYXJ5T3BlcmFuZCwgSWd4TnVtYmVyU3VtbWFyeU9wZXJhbmQsIElneFN1bW1hcnlPcGVyYW5kIH0gZnJvbSAnLi9zdW1tYXJpZXMvZ3JpZC1zdW1tYXJ5JztcbmltcG9ydCB7IElneFJvd0NvbXBvbmVudCB9IGZyb20gJy4vcm93LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hHcmlkSGVhZGVyQ29tcG9uZW50IH0gZnJvbSAnLi9ncmlkLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGVmYXVsdFNvcnRpbmdTdHJhdGVneSwgSVNvcnRpbmdTdHJhdGVneSB9IGZyb20gJy4uL2RhdGEtb3BlcmF0aW9ucy9zb3J0aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IGdldE5vZGVTaXplVmlhUmFuZ2UsIGZsYXR0ZW4gfSBmcm9tICcuLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7XG4gICAgSWd4Qm9vbGVhbkZpbHRlcmluZ09wZXJhbmQsXG4gICAgSWd4TnVtYmVyRmlsdGVyaW5nT3BlcmFuZCxcbiAgICBJZ3hEYXRlRmlsdGVyaW5nT3BlcmFuZCxcbiAgICBJZ3hTdHJpbmdGaWx0ZXJpbmdPcGVyYW5kLFxuICAgIElneEZpbHRlcmluZ09wZXJhbmRcbn0gZnJvbSAnLi4vZGF0YS1vcGVyYXRpb25zL2ZpbHRlcmluZy1jb25kaXRpb24nO1xuaW1wb3J0IHsgSWd4R3JpZEJhc2VDb21wb25lbnQsIElHcmlkRGF0YUJpbmRhYmxlIH0gZnJvbSAnLi9ncmlkLWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSB9IGZyb20gJy4uL2RhdGEtb3BlcmF0aW9ucy9maWx0ZXJpbmctZXhwcmVzc2lvbnMtdHJlZSc7XG5pbXBvcnQgeyBJZ3hHcmlkRmlsdGVyaW5nQ2VsbENvbXBvbmVudCB9IGZyb20gJy4vZmlsdGVyaW5nL2dyaWQtZmlsdGVyaW5nLWNlbGwuY29tcG9uZW50JztcbmltcG9ydCB7IElneEdyaWRIZWFkZXJHcm91cENvbXBvbmVudCB9IGZyb20gJy4vZ3JpZC1oZWFkZXItZ3JvdXAuY29tcG9uZW50JztcbmltcG9ydCB7IERlcHJlY2F0ZVByb3BlcnR5IH0gZnJvbSAnLi4vY29yZS9kZXByZWNhdGVEZWNvcmF0b3JzJztcbmltcG9ydCB7IE1STENvbHVtblNpemVJbmZvLCBNUkxSZXNpemVDb2x1bW5JbmZvIH0gZnJvbSAnLi4vZGF0YS1vcGVyYXRpb25zL211bHRpLXJvdy1sYXlvdXQuaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBEaXNwbGF5RGVuc2l0eSB9IGZyb20gJy4uL2NvcmUvZGlzcGxheURlbnNpdHknO1xuaW1wb3J0IHsgbm90aWZ5Q2hhbmdlcyB9IGZyb20gJy4vd2F0Y2gtY2hhbmdlcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICAgIElneENlbGxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBJZ3hDZWxsSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgSWd4Q2VsbEVkaXRvclRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIElneEZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZVxufSBmcm9tICcuL2NvbW1vbi90ZW1wbGF0ZXMnO1xuXG4vKipcbiAqICoqSWduaXRlIFVJIGZvciBBbmd1bGFyIENvbHVtbioqIC1cbiAqIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5pbmZyYWdpc3RpY3MuY29tL3Byb2R1Y3RzL2lnbml0ZS11aS1hbmd1bGFyL2FuZ3VsYXIvY29tcG9uZW50cy9ncmlkLmh0bWwjY29sdW1ucy1jb25maWd1cmF0aW9uKVxuICpcbiAqIFRoZSBJZ25pdGUgVUkgQ29sdW1uIGlzIHVzZWQgd2l0aGluIGFuIGBpZ3gtZ3JpZGAgZWxlbWVudCB0byBkZWZpbmUgd2hhdCBkYXRhIHRoZSBjb2x1bW4gd2lsbCBzaG93LiBGZWF0dXJlcyBzdWNoIGFzIHNvcnRpbmcsXG4gKiBmaWx0ZXJpbmcgJiBlZGl0aW5nIGFyZSBlbmFibGVkIGF0IHRoZSBjb2x1bW4gbGV2ZWwuICBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHRlbXBsYXRlIGNvbnRhaW5pbmcgY3VzdG9tIGNvbnRlbnQgaW5zaWRlXG4gKiB0aGUgY29sdW1uIHVzaW5nIGBuZy10ZW1wbGF0ZWAgd2hpY2ggd2lsbCBiZSB1c2VkIGZvciBhbGwgY2VsbHMgd2l0aGluIHRoZSBjb2x1bW4uXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICAgIHNlbGVjdG9yOiAnaWd4LWNvbHVtbicsXG4gICAgdGVtcGxhdGU6IGBgXG59KVxuZXhwb3J0IGNsYXNzIElneENvbHVtbkNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBgZmllbGRgIHZhbHVlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uRmllbGQgPSB0aGlzLmNvbHVtbi5maWVsZDtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2ZpZWxkXSA9IFwiJ0lEJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZmllbGQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGBoZWFkZXJgIHZhbHVlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uSGVhZGVyID0gdGhpcy5jb2x1bW4uaGVhZGVyO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbaGVhZGVyXSA9IFwiJ0lEJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaGVhZGVyID0gJyc7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc1NvcnRhYmxlID0gdGhpcy5jb2x1bW4uc29ydGFibGU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtzb3J0YWJsZV0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNvcnRhYmxlID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBncm91cGFibGUuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNHcm91cGFibGUgPSB0aGlzLmNvbHVtbi5ncm91cGFibGU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtncm91cGFibGVdID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcyh0cnVlKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgZ3JvdXBhYmxlID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgZWRpdGFibGUuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNFZGl0YWJsZSA9IHRoaXMuY29sdW1uLmVkaXRhYmxlO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIGdldCBlZGl0YWJsZSgpOiBib29sZWFuIHtcbiAgICAgICAgLy8gVXBkYXRpbmcgdGhlIHByaW1hcnkga2V5IHdoZW4gZ3JpZCBoYXMgdHJhbnNhY3Rpb25zIChpbmNsLiByb3cgZWRpdClcbiAgICAgICAgLy8gc2hvdWxkIG5vdCBiZSBhbGxvd2VkLCBhcyB0aGF0IGNhbiBjb3JydXB0IHRyYW5zYWN0aW9uIHN0YXRlLlxuICAgICAgICBjb25zdCByb3dFZGl0YWJsZSA9IHRoaXMuZ3JpZCAmJiB0aGlzLmdyaWQucm93RWRpdGFibGU7XG4gICAgICAgIGNvbnN0IGhhc1RyYW5zYWN0aW9ucyA9IHRoaXMuZ3JpZCAmJiB0aGlzLmdyaWQudHJhbnNhY3Rpb25zLmVuYWJsZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNQcmltYXJ5Q29sdW1uICYmIChyb3dFZGl0YWJsZSB8fCBoYXNUcmFuc2FjdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZWRpdGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VkaXRhYmxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJvd0VkaXRhYmxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIGVkaXRhYmxlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbi5lZGl0YWJsZSA9IHRydWU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtlZGl0YWJsZV0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBlZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9lZGl0YWJsZSA9IGVkaXRhYmxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIGZpbHRlcmFibGUuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc0ZpbHRlcmFibGUgPSB0aGlzLmNvbHVtbi5maWx0ZXJhYmxlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbZmlsdGVyYWJsZV0gPSBcImZhbHNlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZmlsdGVyYWJsZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyByZXNpemFibGUuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNSZXNpemFibGUgPSB0aGlzLmNvbHVtbi5yZXNpemFibGU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtyZXNpemFibGVdID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyByZXNpemFibGUgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzdW1tYXJ5IGZvciB0aGUgY29sdW1uIGlzIGVuYWJsZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBoYXNTdW1tYXJ5ID0gdGhpcy5jb2x1bW4uaGFzU3VtbWFyeTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXModHJ1ZSlcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIGdldCBoYXNTdW1tYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzU3VtbWFyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3VtbWFyeSBmb3IgdGhlIGNvbHVtbiBpcyBlbmFibGVkLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2hhc1N1bW1hcnldID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgaGFzU3VtbWFyeSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9oYXNTdW1tYXJ5ID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JpZCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLnN1bW1hcnlTZXJ2aWNlLnJlc2V0U3VtbWFyeUhlaWdodCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIGhpZGRlbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzSGlkZGVuID0gdGhpcy5jb2x1bW4uaGlkZGVuO1xuICAgICAqIGBgYFxuICAgICAqQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKHRydWUpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBnZXQgaGlkZGVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlkZGVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2x1bW4gaGlkZGVuIHByb3BlcnR5LlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2hpZGRlbl0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUd28td2F5IGRhdGEgYmluZGluZy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gWyhoaWRkZW4pXSA9IFwibW9kZWwuaXNIaWRkZW5cIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBoaWRkZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2hpZGRlbiAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZGRlbiA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5oaWRkZW5DaGFuZ2UuZW1pdCh0aGlzLl9oaWRkZW4pO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1uTGF5b3V0Q2hpbGQgJiYgdGhpcy5wYXJlbnQuaGlkZGVuICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmhpZGRlbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuZW5kRWRpdChmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLnN1bW1hcnlTZXJ2aWNlLnJlc2V0U3VtbWFyeUhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5maWx0ZXJpbmdTZXJ2aWNlLnJlZnJlc2hFeHByZXNzaW9ucygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5maWx0ZXJpbmdTZXJ2aWNlLmhpZGVGaWx0ZXJpbmdSb3dPbkNvbHVtblZpc2liaWxpdHlDaGFuZ2UodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmdyaWQucmVmcmVzaFNlYXJjaCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBoaWRkZW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBoaWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc0hpZGluZ0Rpc2FibGVkID0gIHRoaXMuY29sdW1uLmRpc2FibGVIaWRpbmc7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIGRpc2FibGVIaWRpbmcgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBpbm5pbmcgaXMgZGlzYWJsZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc1Bpbm5pbmdEaXNhYmxlZCA9ICB0aGlzLmNvbHVtbi5kaXNhYmxlUGlubmluZztcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgZGlzYWJsZVBpbm5pbmcgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIG1vdmFibGUuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNNb3ZhYmxlID0gdGhpcy5jb2x1bW4ubW92YWJsZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW21vdmFibGVdID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgbW92YWJsZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGB3aWR0aGAgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbldpZHRoID0gdGhpcy5jb2x1bW4ud2lkdGg7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKHRydWUpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHdpZHRoKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoU2V0QnlVc2VyID8gdGhpcy5fd2lkdGggOiB0aGlzLmRlZmF1bHRXaWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYHdpZHRoYCBvZiB0aGUgY29sdW1uLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbd2lkdGhdID0gXCInMjUlJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFR3by13YXkgZGF0YSBiaW5kaW5nLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbKHdpZHRoKV09XCJtb2RlbC5jb2x1bW5zWzBdLndpZHRoXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHdpZHRoKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjV2lkdGggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jYWxjUGl4ZWxXaWR0aCA9IE5hTjtcbiAgICAgICAgICAgIHRoaXMud2lkdGhTZXRCeVVzZXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlQ2FsY1dpZHRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndpZHRoQ2hhbmdlLmVtaXQodGhpcy5fd2lkdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHdpZHRoQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBjYWxjV2lkdGgoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FsY1dpZHRoKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY2FsY1dpZHRoID0gbnVsbDtcbiAgICBwdWJsaWMgY2FsY1BpeGVsV2lkdGg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgbWF4aW11bSBgd2lkdGhgIG9mIHRoZSBjb2x1bW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5NYXhXaWR0aCA9IHRoaXMuY29sdW1uLndpZHRoO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbbWF4V2lkdGhdID0gXCInNzUlJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgbWF4V2lkdGg6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIG1pbmltdW0gYHdpZHRoYCBvZiB0aGUgY29sdW1uLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYDg4YDtcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbk1pbldpZHRoID0gdGhpcy5jb2x1bW4ubWluV2lkdGg7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFttaW5XaWR0aF0gPSBcIicxNSUnXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IG1pbldpZHRoKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgbWluVmFsID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4obWluVmFsKSkgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy5fZGVmYXVsdE1pbldpZHRoID0gdmFsdWU7XG5cbiAgICB9XG4gICAgcHVibGljIGdldCBtaW5XaWR0aCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2RlZmF1bHRNaW5XaWR0aCA/IHRoaXMuZGVmYXVsdE1pbldpZHRoIDogdGhpcy5fZGVmYXVsdE1pbldpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGNsYXNzIHNlbGVjdG9yIG9mIHRoZSBjb2x1bW4gaGVhZGVyLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uSGVhZGVyQ2xhc3MgPSB0aGlzLmNvbHVtbi5oZWFkZXJDbGFzc2VzO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbaGVhZGVyQ2xhc3Nlc10gPSBcIidjb2x1bW4taGVhZGVyJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGhlYWRlckNsYXNzZXMgPSAnJztcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgY2xhc3Mgc2VsZWN0b3Igb2YgdGhlIGNvbHVtbiBncm91cCBoZWFkZXIuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5IZWFkZXJDbGFzcyA9IHRoaXMuY29sdW1uLmhlYWRlckdyb3VwQ2xhc3NlcztcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2hlYWRlckdyb3VwQ2xhc3Nlc10gPSBcIidjb2x1bW4tZ3JvdXAtaGVhZGVyJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGhlYWRlckdyb3VwQ2xhc3NlcyA9ICcnO1xuICAgIC8qKlxuICAgICAqIFNldHMgYSBjb25kaXRpb25hbCBjbGFzcyBzZWxlY3RvciBvZiB0aGUgY29sdW1uIGNlbGxzLlxuICAgICAqIEFjY2VwdHMgYW4gb2JqZWN0IGxpdGVyYWwsIGNvbnRhaW5pbmcga2V5LXZhbHVlIHBhaXJzLFxuICAgICAqIHdoZXJlIHRoZSBrZXkgaXMgdGhlIG5hbWUgb2YgdGhlIENTUyBjbGFzcywgd2hpbGUgdGhlXG4gICAgICogdmFsdWUgaXMgZWl0aGVyIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYm9vbGVhbixcbiAgICAgKiBvciBib29sZWFuLCBsaWtlIHNvOlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjYWxsYmFjayA9IChyb3dEYXRhLCBjb2x1bW5LZXksIGNlbGxWYWx1ZSwgcm93SW5kZXgpID0+IHsgcmV0dXJuIHJvd0RhdGFbY29sdW1uS2V5XSA+IDY7IH1cbiAgICAgKiBjZWxsQ2xhc3NlcyA9IHsgJ2NsYXNzTmFtZScgOiB0aGlzLmNhbGxiYWNrIH07XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtjZWxsQ2xhc3Nlc10gPSBcImNlbGxDbGFzc2VzXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDxpZ3gtY29sdW1uIFtjZWxsQ2xhc3Nlc10gPSBcInsnY2xhc3MxJyA6IHRydWUgfVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGNlbGxDbGFzc2VzOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGNvbmRpdGlvbmFsIHN0eWxlIHByb3BlcnRpZXMgb24gdGhlIGNvbHVtbiBjZWxscy5cbiAgICAgKiBTaW1pbGFyIHRvIGBuZ1N0eWxlYCBpdCBhY2NlcHRzIGFuIG9iamVjdCBsaXRlcmFsIHdoZXJlIHRoZSBrZXlzIGFyZVxuICAgICAqIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGFuZCB0aGUgdmFsdWUgaXMgdGhlIGV4cHJlc3Npb24gdG8gYmUgZXZhbHVhdGVkLlxuICAgICAqIEFzIHdpdGggYGNlbGxDbGFzc2VzYCBpdCBhY2NlcHRzIGEgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHN0eWxlcyA9IHtcbiAgICAgKiAgYmFja2dyb3VuZDogJ3JveWFsYmx1ZScsXG4gICAgICogIGNvbG9yOiAocm93RGF0YSwgY29sdW1uS2V5LCBjZWxsVmFsdWUsIHJvd0luZGV4KSA9PiB2YWx1ZS5zdGFydHNXaXRoKCdJbXBvcnRhbnQnKSA6ICdyZWQnOiAnaW5oZXJpdCdcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtjZWxsU3R5bGVzXT1cInN0eWxlc1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBjZWxsU3R5bGVzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gaW5kZXguXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5JbmRleCA9IHRoaXMuY29sdW1uLmluZGV4O1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgaW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5jb2x1bW5zLmluZGV4T2YodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gYXV0b2dlbmVyYXRpbmcgY29sdW1ucywgdGhlIGZvcm1hdHRlciBpcyB1c2VkIHRvIGZvcm1hdCB0aGUgZGlzcGxheSBvZiB0aGUgY29sdW1uIGRhdGFcbiAgICAgKiB3aXRob3V0IG1vZGlmeWluZyB0aGUgdW5kZXJseWluZyBib3VuZCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGV4YW1wbGUsIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgY29sdW1uIG5hbWUgaXMgU2FsYXJ5LCBhbmQgdGhlbiBwcm92aWRlIGEgbWV0aG9kIGFzIHRoZSBjb2x1bW4gZm9ybWF0dGVyXG4gICAgICogdG8gZm9ybWF0IHRoZSB2YWx1ZSBpbnRvIGEgY3VycmVuY3kgc3RyaW5nLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uQ29sdW1uSW5pdChjb2x1bW46IElneENvbHVtbkNvbXBvbmVudCkge1xuICAgICAqICAgaWYgKGNvbHVtbi5maWVsZCA9PSBcIlNhbGFyeVwiKSB7XG4gICAgICogICAgIGNvbHVtbi5mb3JtYXR0ZXIgPSAoc2FsYXJ5ID0+IHRoaXMuZm9ybWF0KHNhbGFyeSkpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZvcm1hdCh2YWx1ZTogbnVtYmVyKSA6IHN0cmluZyB7XG4gICAgICogICByZXR1cm4gZm9ybWF0Q3VycmVuY3kodmFsdWUsIFwiZW4tdXNcIiwgXCIkXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgZm9ybWF0dGVyOiAodmFsdWU6IGFueSkgPT4gYW55O1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gZmlsdGVyaW5nIHNob3VsZCBiZSBjYXNlIHNlbnNpdGl2ZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGZpbHRlcmluZ0lnbm9yZUNhc2UgPSB0aGlzLmNvbHVtbi5maWx0ZXJpbmdJZ25vcmVDYXNlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbZmlsdGVyaW5nSWdub3JlQ2FzZV0gPSBcImZhbHNlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBmaWx0ZXJpbmdJZ25vcmVDYXNlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgY29sdW1uIHNvcnRpbmcgc2hvdWxkIGJlIGNhc2Ugc2Vuc2l0aXZlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYHRydWVgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgc29ydGluZ0lnbm9yZUNhc2UgPSB0aGlzLmNvbHVtbi5zb3J0aW5nSWdub3JlQ2FzZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW3NvcnRpbmdJZ25vcmVDYXNlXSA9IFwiZmFsc2VcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNvcnRpbmdJZ25vcmVDYXNlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgY29sdW1uIHZhbHVlcy5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBzdHJpbmdgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uRGF0YVR5cGUgPSB0aGlzLmNvbHVtbi5kYXRhVHlwZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2RhdGFUeXBlXSA9IFwiJ251bWJlcidcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGRhdGFUeXBlOiBEYXRhVHlwZSA9IERhdGFUeXBlLlN0cmluZztcbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBgcGlubmVkYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzUGlubmVkID0gdGhpcy5jb2x1bW4ucGlubmVkO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgcGlubmVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGlubmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBwaW5uZWQuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbcGlubmVkXSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFR3by13YXkgZGF0YSBiaW5kaW5nLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbKHBpbm5lZCldID0gXCJtb2RlbC5jb2x1bW5zWzBdLmlzUGlubmVkXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHBpbm5lZCh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodGhpcy5fcGlubmVkICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZCAmJiB0aGlzLndpZHRoICYmICFpc05hTihwYXJzZUludCh0aGlzLndpZHRoLCAxMCkpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPyB0aGlzLnBpbigpIDogdGhpcy51bnBpbigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIE5vIGdyaWQvd2lkdGggYXZhaWxhYmxlIGF0IGluaXRpYWxpemF0aW9uLiBgaW5pdFBpbm5pbmdgIGluIHRoZSBncmlkXG4gICAgICAgICAgICAgICB3aWxsIHJlLWluaXQgdGhlIGdyb3VwIChpZiBwcmVzZW50KVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3Bpbm5lZCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5waW5uZWRDaGFuZ2UuZW1pdCh0aGlzLl9waW5uZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHBpbm5lZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogR2V0cy9TZXRzIHRoZSBgaWRgIG9mIHRoZSBgaWd4LWdyaWRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uR3JpZElkID0gdGhpcy5jb2x1bW4uZ3JpZElEO1xuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbi5ncmlkSUQgPSAnZ3JpZC0xJztcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQERlcHJlY2F0ZVByb3BlcnR5KGBUaGUgcHJvcGVydHkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlLCB1c2UgXFxgY29sdW1uLmdyaWQuaWRcXGAgaW5zdGVhZC5gKVxuICAgIHB1YmxpYyBncmlkSUQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gYHN1bW1hcmllc2AuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5TdW1tYXJpZXMgPSB0aGlzLmNvbHVtbi5zdW1tYXJpZXM7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKHRydWUpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHN1bW1hcmllcygpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VtbWFyaWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2x1bW4gYHN1bW1hcmllc2AuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLnN1bW1hcmllcyA9IElneE51bWJlclN1bW1hcnlPcGVyYW5kO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHN1bW1hcmllcyhjbGFzc1JlZjogYW55KSB7XG4gICAgICAgIHRoaXMuX3N1bW1hcmllcyA9IG5ldyBjbGFzc1JlZigpO1xuXG4gICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5zdW1tYXJ5U2VydmljZS5yZW1vdmVTdW1tYXJpZXNDYWNoZVBlckNvbHVtbih0aGlzLmZpZWxkKTtcbiAgICAgICAgICAgICh0aGlzLmdyaWQgYXMgYW55KS5fc3VtbWFyeVBpcGVUcmlnZ2VyKys7XG4gICAgICAgICAgICB0aGlzLmdyaWQuc3VtbWFyeVNlcnZpY2UucmVzZXRTdW1tYXJ5SGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBgc2VhcmNoYWJsZWAuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc1NlYXJjaGFibGUgPSAgdGhpcy5jb2x1bW4uc2VhcmNoYWJsZSc7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqICA8aWd4LWNvbHVtbiBbc2VhcmNoYWJsZV0gPSBcImZhbHNlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2VhcmNoYWJsZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29sdW1uIGBmaWx0ZXJzYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkZpbHRlcnMgPSB0aGlzLmNvbHVtbi5maWx0ZXJzJ1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgZmlsdGVycygpOiBJZ3hGaWx0ZXJpbmdPcGVyYW5kIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbHVtbiBgZmlsdGVyc2AuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLmZpbHRlcnMgPSBJZ3hCb29sZWFuRmlsdGVyaW5nT3BlcmFuZC5pbnN0YW5jZSgpLlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGZpbHRlcnMoaW5zdGFuY2U6IElneEZpbHRlcmluZ09wZXJhbmQpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVycyA9IGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gYHNvcnRTdHJhdGVneWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBzb3J0U3RyYXRlZ3kgPSB0aGlzLmNvbHVtbi5zb3J0U3RyYXRlZ3lcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHNvcnRTdHJhdGVneSgpOiBJU29ydGluZ1N0cmF0ZWd5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvcnRTdHJhdGVneTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29sdW1uIGBzb3J0U3RyYXRlZ3lgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbi5zb3J0U3RyYXRlZ3kgPSBuZXcgQ3VzdG9tU29ydGluZ1N0cmF0ZWd5KCkuXG4gICAgICogY2xhc3MgQ3VzdG9tU29ydGluZ1N0cmF0ZWd5IGV4dGVuZHMgU29ydGluZ1N0cmF0ZWd5IHsuLi59XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgc29ydFN0cmF0ZWd5KGNsYXNzUmVmOiBJU29ydGluZ1N0cmF0ZWd5KSB7XG4gICAgICAgIHRoaXMuX3NvcnRTdHJhdGVneSA9IGNsYXNzUmVmO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHRoYXQgY29tcGFyZXMgdmFsdWVzIGZvciBncm91cGluZy5cbiAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAqIGxldCBncm91cGluZ0NvbXBhcmVyID0gdGhpcy5jb2x1bW4uZ3JvdXBpbmdDb21wYXJlcidcbiAgICAqIGBgYFxuICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGdyb3VwaW5nQ29tcGFyZXIoKTogKGE6IGFueSwgYjogYW55KSA9PiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBpbmdDb21wYXJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIGN1c3RvbSBmdW5jdGlvbiB0byBjb21wYXJlIHZhbHVlcyBmb3IgZ3JvdXBpbmcuXG4gICAgICogU3Vic2VxdWVudCB2YWx1ZXMgaW4gdGhlIHNvcnRlZCBkYXRhIHRoYXQgdGhlIGZ1bmN0aW9uIHJldHVybnMgMCBmb3IgYXJlIGdyb3VwZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLmdyb3VwaW5nQ29tcGFyZXIgPSAoYTogYW55LCBiOiBhbnkpID0+IHsgcmV0dXJuIGEgPT09IGIgPyAwIDogLTE7IH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHNldCBncm91cGluZ0NvbXBhcmVyKGZ1bmNSZWY6IChhOiBhbnksIGI6IGFueSkgPT4gbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwaW5nQ29tcGFyZXIgPSBmdW5jUmVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IG1pbmltdW0gYHdpZHRoYCBvZiB0aGUgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZGVmYXVsdE1pbldpZHRoID0gIHRoaXMuY29sdW1uLmRlZmF1bHRNaW5XaWR0aDtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGRlZmF1bHRNaW5XaWR0aCgpOiBzdHJpbmcge1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZCkgeyByZXR1cm4gJzgwJzsgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMuZ3JpZC5kaXNwbGF5RGVuc2l0eSkge1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb3N5OlxuICAgICAgICAgICAgICAgIHJldHVybiAnNjQnO1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnNTYnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJzgwJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVmZXJlbmNlIHRvIHRoZSBgaWd4LWdyaWRgIG93bmVyLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZ3JpZENvbXBvbmVudCA9IHRoaXMuY29sdW1uLmdyaWQ7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZ3JpZCgpOiBJZ3hHcmlkQmFzZUNvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWRBUEkuZ3JpZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYGJvZHlUZW1wbGF0ZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBib2R5VGVtcGxhdGUgPSB0aGlzLmNvbHVtbi5ib2R5VGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoJ2NlbGxUZW1wbGF0ZScpXG4gICAgZ2V0IGJvZHlUZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHlUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm9keSB0ZW1wbGF0ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNib2R5VGVtcGxhdGUgaWd4Q2VsbCBsZXQtdmFsPlxuICAgICAqICAgIDxkaXYgc3R5bGUgPSBcImJhY2tncm91bmQtY29sb3I6IHllbGxvd2dyZWVuXCIgKGNsaWNrKSA9IFwiY2hhbmdlQ29sb3IodmFsKVwiPlxuICAgICAqICAgICAgIDxzcGFuPiB7e3ZhbH19IDwvc3Bhbj5cbiAgICAgKiAgICA8L2Rpdj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiJ2JvZHlUZW1wbGF0ZSdcIiwge3JlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgICogcHVibGljIGJvZHlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAgKiB0aGlzLmNvbHVtbi5ib2R5VGVtcGxhdGUgPSB0aGlzLmJvZHlUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IGJvZHlUZW1wbGF0ZSh0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Pikge1xuICAgICAgICB0aGlzLl9ib2R5VGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgaGVhZGVyIHRlbXBsYXRlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaGVhZGVyVGVtcGxhdGUgPSB0aGlzLmNvbHVtbi5oZWFkZXJUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGhlYWRlclRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyVGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlYWRlciB0ZW1wbGF0ZS5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIGNvbHVtbiBoZWFkZXIgaGVpZ2h0IGlzIGZpeGVkIGFuZCBhbnkgY29udGVudCBiaWdnZXIgdGhhbiBpdCB3aWxsIGJlIGN1dCBvZmYuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSAjaGVhZGVyVGVtcGxhdGU+XG4gICAgICogICA8ZGl2IHN0eWxlID0gXCJiYWNrZ3JvdW5kLWNvbG9yOmJsYWNrXCIgKGNsaWNrKSA9IFwiY2hhbmdlQ29sb3IodmFsKVwiPlxuICAgICAqICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkXCIgPnt7Y29sdW1uLmZpZWxkfX08L3NwYW4+XG4gICAgICogICA8L2Rpdj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiJ2hlYWRlclRlbXBsYXRlJ1wiLCB7cmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICAgKiBwdWJsaWMgaGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgICogdGhpcy5jb2x1bW4uaGVhZGVyVGVtcGxhdGUgPSB0aGlzLmhlYWRlclRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgaGVhZGVyVGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pIHtcbiAgICAgICAgdGhpcy5faGVhZGVyVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgaW5saW5lIGVkaXRvciB0ZW1wbGF0ZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlubGluZUVkaXRvclRlbXBsYXRlID0gdGhpcy5jb2x1bW4uaW5saW5lRWRpdG9yVGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoJ2NlbGxFZGl0b3JUZW1wbGF0ZScpXG4gICAgZ2V0IGlubGluZUVkaXRvclRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5saW5lRWRpdG9yVGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGlubGluZSBlZGl0b3IgdGVtcGxhdGUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSAjaW5saW5lRWRpdG9yVGVtcGxhdGUgaWd4Q2VsbEVkaXRvciBsZXQtY2VsbD1cImNlbGxcIj5cbiAgICAgKiAgICAgPGlucHV0IHR5cGU9XCJzdHJpbmdcIiBbKG5nTW9kZWwpXT1cImNlbGwudmFsdWVcIi8+XG4gICAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIidpbmxpbmVFZGl0b3JUZW1wbGF0ZSdcIiwge3JlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgICogcHVibGljIGlubGluZUVkaXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgICAqIHRoaXMuY29sdW1uLmlubGluZUVkaXRvclRlbXBsYXRlID0gdGhpcy5pbmxpbmVFZGl0b3JUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IGlubGluZUVkaXRvclRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgICAgIHRoaXMuX2lubGluZUVkaXRvclRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBmaWx0ZXJDZWxsVGVtcGxhdGVgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZmlsdGVyQ2VsbFRlbXBsYXRlID0gdGhpcy5jb2x1bW4uZmlsdGVyQ2VsbFRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KCdmaWx0ZXJDZWxsVGVtcGxhdGUnKVxuICAgIGdldCBmaWx0ZXJDZWxsVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJDZWxsVGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHF1aWNrIGZpbHRlciB0ZW1wbGF0ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNmaWx0ZXJDZWxsVGVtcGxhdGUgSWd4RmlsdGVyQ2VsbFRlbXBsYXRlIGxldC1jb2x1bW49XCJjb2x1bW5cIj5cbiAgICAgKiAgICA8aW5wdXQgKGlucHV0KT1cIm9uSW5wdXQoKVwiPlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCInZmlsdGVyQ2VsbFRlbXBsYXRlJ1wiLCB7cmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICAgKiBwdWJsaWMgZmlsdGVyQ2VsbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgICAqIHRoaXMuY29sdW1uLmZpbHRlckNlbGxUZW1wbGF0ZSA9IHRoaXMuZmlsdGVyQ2VsbFRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgZmlsdGVyQ2VsbFRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlckNlbGxUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjZWxscyBvZiB0aGUgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uQ2VsbHMgPSAgdGhpcy5jb2x1bW4uY2VsbHM7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBjZWxscygpOiBJZ3hHcmlkQ2VsbENvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5yb3dMaXN0LmZpbHRlcigocm93KSA9PiByb3cgaW5zdGFuY2VvZiBJZ3hSb3dDb21wb25lbnQpXG4gICAgICAgICAgICAubWFwKChyb3cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocm93LmNlbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3cuY2VsbHMuZmlsdGVyKChjZWxsKSA9PiBjZWxsLmNvbHVtbkluZGV4ID09PSB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbHVtbiB2aXNpYmxlIGluZGV4LlxuICAgICAqIElmIHRoZSBjb2x1bW4gaXMgbm90IHZpc2libGUsIHJldHVybnMgYC0xYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHZpc2libGVDb2x1bW5JbmRleCA9ICB0aGlzLmNvbHVtbi52aXNpYmxlSW5kZXg7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCB2aXNpYmxlSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKCFpc05hTih0aGlzLl92SW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdkluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVucGlubmVkQ29sdW1ucyA9IHRoaXMuZ3JpZC51bnBpbm5lZENvbHVtbnMuZmlsdGVyKGMgPT4gIWMuY29sdW1uR3JvdXApO1xuICAgICAgICBjb25zdCBwaW5uZWRDb2x1bW5zID0gdGhpcy5ncmlkLnBpbm5lZENvbHVtbnMuZmlsdGVyKGMgPT4gIWMuY29sdW1uR3JvdXApO1xuICAgICAgICBsZXQgY29sID0gdGhpcztcbiAgICAgICAgbGV0IHZJbmRleCA9IC0xO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkdyb3VwKSB7XG4gICAgICAgICAgICBjb2wgPSB0aGlzLmFsbENoaWxkcmVuLmZpbHRlcihjID0+ICFjLmNvbHVtbkdyb3VwKVswXSBhcyBhbnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uTGF5b3V0Q2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZHJlblZpc2libGVJbmRleGVzLmZpbmQoeCA9PiB4LmNvbHVtbiA9PT0gdGhpcykuaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMucGlubmVkKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleEluQ29sbGVjdGlvbiA9IHVucGlubmVkQ29sdW1ucy5pbmRleE9mKGNvbCk7XG4gICAgICAgICAgICB2SW5kZXggPSBpbmRleEluQ29sbGVjdGlvbiA9PT0gLTEgPyAtMSA6IHBpbm5lZENvbHVtbnMubGVuZ3RoICsgaW5kZXhJbkNvbGxlY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2SW5kZXggPSBwaW5uZWRDb2x1bW5zLmluZGV4T2YoY29sKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92SW5kZXggPSB2SW5kZXg7XG4gICAgICAgIHJldHVybiB2SW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGNvbHVtbiBpcyBhIGBDb2x1bW5Hcm91cGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5Hcm91cCA9ICB0aGlzLmNvbHVtbi5jb2x1bW5Hcm91cDtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGNvbHVtbkdyb3VwKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGNvbHVtbiBpcyBhIGBDb2x1bW5MYXlvdXRgIGZvciBtdWx0aS1yb3cgbGF5b3V0LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uR3JvdXAgPSAgdGhpcy5jb2x1bW4uY29sdW1uR3JvdXA7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBjb2x1bW5MYXlvdXQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGNvbHVtbiBpcyBhIGNoaWxkIG9mIGEgYENvbHVtbkxheW91dGAgZm9yIG11bHRpLXJvdyBsYXlvdXQuXG4gICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgKiBsZXQgY29sdW1uTGF5b3V0Q2hpbGQgPSAgdGhpcy5jb2x1bW4uY29sdW1uTGF5b3V0Q2hpbGQ7XG4gICAgKiBgYGBcbiAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAqL1xuICAgIGdldCBjb2x1bW5MYXlvdXRDaGlsZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmNvbHVtbkxheW91dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjaGlsZHJlbiBjb2x1bW5zIGNvbGxlY3Rpb24uXG4gICAgICogUmV0dXJucyBhbiBlbXB0eSBhcnJheSBpZiB0aGUgY29sdW1uIGRvZXMgbm90IGNvbnRhaW4gY2hpbGRyZW4gY29sdW1ucy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNoaWxkcmVuQ29sdW1ucyA9ICB0aGlzLmNvbHVtbi5hbGxDaGlsZHJlbjtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGFsbENoaWxkcmVuKCk6IElneENvbHVtbkNvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZXZlbCBvZiB0aGUgY29sdW1uIGluIGEgY29sdW1uIGdyb3VwLlxuICAgICAqIFJldHVybnMgYDBgIGlmIHRoZSBjb2x1bW4gZG9lc24ndCBoYXZlIGEgYHBhcmVudGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5MZXZlbCA9ICB0aGlzLmNvbHVtbi5sZXZlbDtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGxldmVsKCkge1xuICAgICAgICBsZXQgcHRyID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGxldCBsdmwgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwdHIpIHtcbiAgICAgICAgICAgIGx2bCsrO1xuICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbHZsO1xuICAgIH1cblxuICAgIGdldCBpc0xhc3RQaW5uZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucGlubmVkQ29sdW1uc1t0aGlzLmdyaWQucGlubmVkQ29sdW1ucy5sZW5ndGggLSAxXSA9PT0gdGhpcztcbiAgICB9XG4gICAgZ2V0IGdyaWRSb3dTcGFuKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd0VuZCAmJiB0aGlzLnJvd1N0YXJ0ID8gdGhpcy5yb3dFbmQgLSB0aGlzLnJvd1N0YXJ0IDogMTtcbiAgICB9XG4gICAgZ2V0IGdyaWRDb2x1bW5TcGFuKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbEVuZCAmJiB0aGlzLmNvbFN0YXJ0ID8gdGhpcy5jb2xFbmQgLSB0aGlzLmNvbFN0YXJ0IDogMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3cgaW5kZXggd2hlcmUgdGhlIGN1cnJlbnQgZmllbGQgc2hvdWxkIGVuZC5cbiAgICAgKiBUaGUgYW1vdW50IG9mIHJvd3MgYmV0d2VlbiByb3dTdGFydCBhbmQgcm93RW5kIHdpbGwgZGV0ZXJtaW5lIHRoZSBhbW91bnQgb2Ygc3Bhbm5pbmcgcm93cyB0byB0aGF0IGZpZWxkXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiAgIDxpZ3gtY29sdW1uIFtyb3dFbmRdPVwiMlwiIFtyb3dTdGFydF09XCIxXCIgW2NvbFN0YXJ0XT1cIjFcIj48L2lneC1jb2x1bW4+XG4gICAgICogPC9pZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgcm93RW5kOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDb2x1bW4gaW5kZXggd2hlcmUgdGhlIGN1cnJlbnQgZmllbGQgc2hvdWxkIGVuZC5cbiAgICAgKiBUaGUgYW1vdW50IG9mIGNvbHVtbnMgYmV0d2VlbiBjb2xTdGFydCBhbmQgY29sRW5kIHdpbGwgZGV0ZXJtaW5lIHRoZSBhbW91bnQgb2Ygc3Bhbm5pbmcgY29sdW1ucyB0byB0aGF0IGZpZWxkXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiAgIDxpZ3gtY29sdW1uIFtjb2xFbmRdPVwiM1wiIFtyb3dTdGFydF09XCIxXCIgW2NvbFN0YXJ0XT1cIjFcIj48L2lneC1jb2x1bW4+XG4gICAgICogPC9pZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY29sRW5kOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBSb3cgaW5kZXggZnJvbSB3aGljaCB0aGUgZmllbGQgaXMgc3RhcnRpbmcuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiAgIDxpZ3gtY29sdW1uIFtyb3dTdGFydF09XCIxXCIgW2NvbFN0YXJ0XT1cIjFcIj48L2lneC1jb2x1bW4+XG4gICAgICogPC9pZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KCkgcm93U3RhcnQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIENvbHVtbiBpbmRleCBmcm9tIHdoaWNoIHRoZSBmaWVsZCBpcyBzdGFydGluZy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4tbGF5b3V0PlxuICAgICAqICAgPGlneC1jb2x1bW4gW2NvbFN0YXJ0XT1cIjFcIiBbcm93U3RhcnRdPVwiMVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiA8L2lneC1jb2x1bW4tbGF5b3V0PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKSBjb2xTdGFydDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGRlZmF1bHRXaWR0aDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHdpZHRoU2V0QnlVc2VyOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIG9mIHRoZSBjb2x1bW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCB0cmVlID0gIHRoaXMuY29sdW1uLmZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSgpOiBGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZS5maW5kKHRoaXMuZmllbGQpIGFzIEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBwYXJlbnQgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgcGFyZW50Q29sdW1uID0gdGhpcy5jb2x1bW4ucGFyZW50O1xuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbi5wYXJlbnQgPSBoaWdoZXJMZXZlbENvbHVtbjtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcGFyZW50ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGNoaWxkcmVuIGNvbHVtbnMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5DaGlsZHJlbiA9IHRoaXMuY29sdW1uLmNoaWxkcmVuO1xuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbi5jaGlsZHJlbiA9IGNoaWxkcmVuQ29sdW1ucztcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgY2hpbGRyZW46IFF1ZXJ5TGlzdDxJZ3hDb2x1bW5Db21wb25lbnQ+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGVzdHJveSQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF91bnBpbm5lZEluZGV4O1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfcGlubmVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9ib2R5VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9oZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2lubGluZUVkaXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZmlsdGVyQ2VsbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfc3VtbWFyaWVzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2ZpbHRlcnMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfc29ydFN0cmF0ZWd5OiBJU29ydGluZ1N0cmF0ZWd5ID0gRGVmYXVsdFNvcnRpbmdTdHJhdGVneS5pbnN0YW5jZSgpO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZ3JvdXBpbmdDb21wYXJlcjogKGE6IGFueSwgYjogYW55KSA9PiBudW1iZXI7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9oaWRkZW4gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2luZGV4OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kaXNhYmxlUGlubmluZyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfd2lkdGg6IHN0cmluZztcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2RlZmF1bHRNaW5XaWR0aCA9ICcnO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfaGFzU3VtbWFyeSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2VkaXRhYmxlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0IGlzUHJpbWFyeUNvbHVtbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmdyaWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpZWxkID09PSB0aGlzLmdyaWQucHJpbWFyeUtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4Q2VsbFRlbXBsYXRlRGlyZWN0aXZlLCBzdGF0aWM6IGZhbHNlIH0pXG4gICAgcHJvdGVjdGVkIGNlbGxUZW1wbGF0ZTogSWd4Q2VsbFRlbXBsYXRlRGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oSWd4Q2VsbEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IElneENlbGxIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSwgZGVzY2VuZGFudHM6IGZhbHNlIH0pXG4gICAgcHJvdGVjdGVkIGhlYWRUZW1wbGF0ZTogUXVlcnlMaXN0PElneENlbGxIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZT47XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hDZWxsRWRpdG9yVGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4Q2VsbEVkaXRvclRlbXBsYXRlRGlyZWN0aXZlLCBzdGF0aWM6IGZhbHNlIH0pXG4gICAgcHJvdGVjdGVkIGVkaXRvclRlbXBsYXRlOiBJZ3hDZWxsRWRpdG9yVGVtcGxhdGVEaXJlY3RpdmU7XG5cbiAgICBwcm90ZWN0ZWQgX3ZJbmRleCA9IE5hTjtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneEZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hGaWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHN0YXRpYzogZmFsc2UgfSlcbiAgICBwdWJsaWMgZmlsdGVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlOiBJZ3hGaWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmU7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZ3JpZEFQSTogR3JpZEJhc2VBUElTZXJ2aWNlPElneEdyaWRCYXNlQ29tcG9uZW50ICYgSUdyaWREYXRhQmluZGFibGU+LCBwdWJsaWMgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHVibGljIHJvd0lzbGFuZEFQSTogSWd4Um93SXNsYW5kQVBJU2VydmljZSkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHJlc2V0Q2FjaGVzKCkge1xuICAgICAgICB0aGlzLl92SW5kZXggPSBOYU47XG4gICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVDYWxjV2lkdGgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fYm9keVRlbXBsYXRlID0gdGhpcy5jZWxsVGVtcGxhdGUudGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGVhZFRlbXBsYXRlICYmIHRoaXMuaGVhZFRlbXBsYXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyVGVtcGxhdGUgPSB0aGlzLmhlYWRUZW1wbGF0ZS50b0FycmF5KClbMF0udGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lubGluZUVkaXRvclRlbXBsYXRlID0gdGhpcy5lZGl0b3JUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlckNlbGxUZW1wbGF0ZSA9IHRoaXMuZmlsdGVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLnRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zdW1tYXJpZXMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXRhVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuU3RyaW5nOlxuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuQm9vbGVhbjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdW1tYXJpZXMgPSBJZ3hTdW1tYXJ5T3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhVHlwZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyaWVzID0gSWd4TnVtYmVyU3VtbWFyeU9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuRGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdW1tYXJpZXMgPSBJZ3hEYXRlU3VtbWFyeU9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyaWVzID0gSWd4U3VtbWFyeU9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF0YVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFUeXBlLkJvb2xlYW46XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVycyA9IElneEJvb2xlYW5GaWx0ZXJpbmdPcGVyYW5kLmluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuTnVtYmVyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcnMgPSBJZ3hOdW1iZXJGaWx0ZXJpbmdPcGVyYW5kLmluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuRGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gSWd4RGF0ZUZpbHRlcmluZ09wZXJhbmQuaW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhVHlwZS5TdHJpbmc6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gSWd4U3RyaW5nRmlsdGVyaW5nT3BlcmFuZC5pbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXRHcmlkVGVtcGxhdGUoaXNSb3c6IGJvb2xlYW4sIGlzSUU6IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgICAgICBpZiAoaXNSb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvd3NDb3VudCA9IHRoaXMuZ3JpZC5tdWx0aVJvd0xheW91dFJvd1NpemU7XG4gICAgICAgICAgICByZXR1cm4gaXNJRSA/XG4gICAgICAgICAgICAgICAgYCgxZnIpWyR7cm93c0NvdW50fV1gIDpcbiAgICAgICAgICAgICAgICBgcmVwZWF0KCR7cm93c0NvdW50fSwxZnIpYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtblNpemVzU3RyaW5nKHRoaXMuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldEluaXRpYWxDaGlsZENvbHVtblNpemVzKGNoaWxkcmVuOiBRdWVyeUxpc3Q8SWd4Q29sdW1uQ29tcG9uZW50Pik6IEFycmF5PE1STENvbHVtblNpemVJbmZvPiB7XG4gICAgICAgIGNvbnN0IGNvbHVtblNpemVzOiBNUkxDb2x1bW5TaXplSW5mb1tdID0gW107XG4gICAgICAgIC8vIGZpbmQgdGhlIHNtYWxsZXN0IGNvbCBzcGFuc1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNvbCA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbC5jb2xTdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld1dpZHRoU2V0ID0gY29sLndpZHRoU2V0QnlVc2VyICYmIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdICYmICFjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXS53aWR0aFNldEJ5VXNlcjtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NwYW5TbWFsbGVyID0gY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0gJiYgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0uY29sU3BhbiA+IGNvbC5ncmlkQ29sdW1uU3BhbjtcbiAgICAgICAgICAgIGNvbnN0IGJvdGhXaWR0aHNTZXQgPSBjb2wud2lkdGhTZXRCeVVzZXIgJiYgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0gJiYgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0ud2lkdGhTZXRCeVVzZXI7XG4gICAgICAgICAgICBjb25zdCBib3RoV2lkdGhzTm90U2V0ID0gIWNvbC53aWR0aFNldEJ5VXNlciAmJiBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXSAmJiAhY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0ud2lkdGhTZXRCeVVzZXI7XG5cbiAgICAgICAgICAgIGlmIChjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm90aGluZyBpcyBkZWZpbmVkIHlldCB0YWtlIGFueSBjb2x1bW4gYXQgZmlyc3RcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgY29sRW5kIHRvIGtub3cgd2hlcmUgdGhlIGNvbHVtbiBhY3R1YWxseSBlbmRzLCBiZWNhdXNlIG5vdCBhbHdheXMgaXQgc3RhcnRzIHdoZXJlIHdlIGhhdmUgaXQgc2V0IGluIGNvbHVtblNpemVzLlxuICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdID0ge1xuICAgICAgICAgICAgICAgICAgICByZWY6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbC53aWR0aFNldEJ5VXNlciB8fCB0aGlzLmdyaWQuY29sdW1uV2lkdGhTZXRCeVVzZXIgPyBwYXJzZUludChjb2wuY2FsY1dpZHRoLCAxMCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjb2xTcGFuOiBjb2wuZ3JpZENvbHVtblNwYW4sXG4gICAgICAgICAgICAgICAgICAgIGNvbEVuZDogY29sLmNvbFN0YXJ0ICsgY29sLmdyaWRDb2x1bW5TcGFuLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aFNldEJ5VXNlcjogY29sLndpZHRoU2V0QnlVc2VyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3V2lkdGhTZXQgfHwgKG5ld1NwYW5TbWFsbGVyICYmICgoYm90aFdpZHRoc1NldCkgfHwgKGJvdGhXaWR0aHNOb3RTZXQpKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIGNvbHVtbiBpcyBzZXQgYWxyZWFkeSBpdCBzaG91bGQgZWl0aGVyIG5vdCBoYXZlIHdpZHRoIGRlZmluZWQgb3IgaGF2ZSB3aWR0aCB3aXRoIGJpZ2dlciBzcGFuIHRoYW4gdGhlIG5ldyBvbmUuXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiAgSWYgcmVwbGFjZWQgY29sdW1uIGhhcyBiaWdnZXIgc3Bhbiwgd2Ugd2FudCB0byBmaWxsIHRoZSByZW1haW5pbmcgY29sdW1uc1xuICAgICAgICAgICAgICAgICAqICB0aGF0IHRoZSByZXBsYWNpbmcgY29sdW1uIGRvZXMgbm90IGZpbGwgd2l0aCB0aGUgb2xkIG9uZS5cbiAgICAgICAgICAgICAgICAgKiovXG4gICAgICAgICAgICAgICAgaWYgKGJvdGhXaWR0aHNTZXQgJiYgbmV3U3BhblNtYWxsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSB3aGVyZSB0aGUgbmV3IGNvbHVtbiBzZXQgd291bGQgZW5kIGFuZCBhcHBseSB0aGUgb2xkIGNvbHVtbiB0byB0aGUgcmVzdCBkZXBlbmRpbmcgb24gaG93IG11Y2ggaXQgc3BhbnMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgbm90IHlldCByZXBsYWNlZCBpdCBzbyB3ZSBjYW4gdXNlIGl0IGRpcmVjdGx5IGZyb20gdGhlIGNvbHVtblNpemVzIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgd2hlcmUgY29sRW5kIGlzIHVzZWQgYmVjYXVzZSB0aGUgY29sU3RhcnQgb2YgdGhlIG9sZCBjb2x1bW4gaXMgbm90IGFjdHVhbGx5IGkgKyAxLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gY29sLmNvbFN0YXJ0IC0gMSArIGNvbC5ncmlkQ29sdW1uU3BhbjsgaSA8IGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLmNvbEVuZCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2x1bW5TaXplc1tpXSB8fCAhY29sdW1uU2l6ZXNbaV0ud2lkdGhTZXRCeVVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXSA9IGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIG9sZCBjb2x1bW4gd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2wud2lkdGhTZXRCeVVzZXIgfHwgdGhpcy5ncmlkLmNvbHVtbldpZHRoU2V0QnlVc2VyID8gcGFyc2VJbnQoY29sLmNhbGNXaWR0aCwgMTApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY29sU3BhbjogY29sLmdyaWRDb2x1bW5TcGFuLFxuICAgICAgICAgICAgICAgICAgICBjb2xFbmQ6IGNvbC5jb2xTdGFydCArIGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhTZXRCeVVzZXI6IGNvbC53aWR0aFNldEJ5VXNlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJvdGhXaWR0aHNTZXQgJiYgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0uY29sU3BhbiA8IGNvbC5ncmlkQ29sdW1uU3Bhbikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gYWxyZWFkeSBpbiB0aGUgY29sdW1uU2l6ZXMgaGFzIHNtYWxsZXIgc3Bhbiwgd2Ugc3RpbGwgbmVlZCB0byBmaWxsIGFueSBlbXB0eSBwbGFjZXMgd2l0aCB0aGUgY3VycmVudCBjb2wuXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSB3aGVyZSB0aGUgc21hbGxlciBjb2x1bW4gc2V0IHdvdWxkIGVuZCBhbmQgYXBwbHkgdGhlIGJpZ2dlciBjb2x1bW4gdG8gdGhlIHJlc3QgZGVwZW5kaW5nIG9uIGhvdyBtdWNoIGl0IHNwYW5zLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIGhlcmUgd2UgZG8gbm90IGhhdmUgaXQgaW4gY29sdW1uU2l6ZXMgd2Ugc2V0IGl0IGFzIGEgbmV3IGNvbHVtbiBrZWVwaW5nIHRoZSBzYW1lIGNvbFNwYW4uXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbC5jb2xTdGFydCAtIDEgKyBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXS5jb2xTcGFuOyBpIDwgY29sLmNvbFN0YXJ0IC0gMSArIGNvbC5ncmlkQ29sdW1uU3BhbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29sdW1uU2l6ZXNbaV0gfHwgIWNvbHVtblNpemVzW2ldLndpZHRoU2V0QnlVc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29sLndpZHRoU2V0QnlVc2VyIHx8IHRoaXMuZ3JpZC5jb2x1bW5XaWR0aFNldEJ5VXNlciA/IHBhcnNlSW50KGNvbC5jYWxjV2lkdGgsIDEwKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sU3BhbjogY29sLmdyaWRDb2x1bW5TcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbEVuZDogY29sLmNvbFN0YXJ0ICsgY29sLmdyaWRDb2x1bW5TcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoU2V0QnlVc2VyOiBjb2wud2lkdGhTZXRCeVVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmxhdHRlbiBjb2x1bW5TaXplcyBzbyB0aGVyZSBhcmUgbm90IGNvbHVtbnMgd2l0aCBjb2xTcGFuID4gMVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtblNpemVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29sdW1uU2l6ZXNbaV0gJiYgY29sdW1uU2l6ZXNbaV0uY29sU3BhbiA+IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgaiA9IDE7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGFsbCBlbXB0eSBwbGFjZXMgZGVwZW5kaW5nIG9uIGhvdyBtdWNoIHRoZSBjdXJyZW50IGNvbHVtbiBzcGFucyBzdGFydGluZyBmcm9tIG5leHQgY29sLlxuICAgICAgICAgICAgICAgIGZvciAoOyBqIDwgY29sdW1uU2l6ZXNbaV0uY29sU3BhbiAmJiBpICsgaiArIDEgPCBjb2x1bW5TaXplc1tpXS5jb2xFbmQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uU2l6ZXNbaSArIGpdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoKCFjb2x1bW5TaXplc1tpXS53aWR0aCAmJiBjb2x1bW5TaXplc1tpICsgal0ud2lkdGgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFjb2x1bW5TaXplc1tpXS53aWR0aCAmJiAhY29sdW1uU2l6ZXNbaSArIGpdLndpZHRoICYmIGNvbHVtblNpemVzW2kgKyBqXS5jb2xTcGFuIDw9IGNvbHVtblNpemVzW2ldLmNvbFNwYW4pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCEhY29sdW1uU2l6ZXNbaSArIGpdLndpZHRoICYmIGNvbHVtblNpemVzW2kgKyBqXS5jb2xTcGFuIDw9IGNvbHVtblNpemVzW2ldLmNvbFNwYW4pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2ggYW4gYWxyZWFkeSBkZWZpbmVkIGNvbHVtbiB0aGF0IGhhcyB3aWR0aCBhbmQgdGhlIGN1cnJlbnQgZG9lc24ndCBoYXZlIG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcmVhY2hlZCBjb2x1bW4gaGFzIGJpZ2dlciBjb2xTcGFuIHdlIHN0b3AuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gY29sdW1uU2l6ZXNbaV0ud2lkdGhTZXRCeVVzZXIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2ldLndpZHRoIC8gY29sdW1uU2l6ZXNbaV0uY29sU3BhbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uU2l6ZXNbaV0ud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpICsgal0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBjb2x1bW5TaXplc1tpXS5yZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbFNwYW46IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sRW5kOiBjb2x1bW5TaXplc1tpXS5jb2xFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhTZXRCeVVzZXI6IGNvbHVtblNpemVzW2ldLndpZHRoU2V0QnlVc2VyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGNvbHVtbiB3aWR0aCBzbyBpdCBpcyBkaXZpZGVkIGJldHdlZW4gYWxsIGNvbHVtbnMgaXQgc3BhbnMgYW5kIHNldCBpdCB0byAxLlxuICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2ldLndpZHRoID0gY29sdW1uU2l6ZXNbaV0ud2lkdGhTZXRCeVVzZXIgP1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXS53aWR0aCAvIGNvbHVtblNpemVzW2ldLmNvbFNwYW4gOlxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXS53aWR0aDtcbiAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXS5jb2xTcGFuID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW5kZXggYmFzZWQgb24gaG93IG11Y2ggd2UgaGF2ZSByZXBsYWNlZC4gU3VidHJhY3QgMSBiZWNhdXNlIHdlIHN0YXJ0ZWQgZnJvbSAxLlxuICAgICAgICAgICAgICAgIGkgKz0gaiAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sdW1uU2l6ZXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldEZpbGxlZENoaWxkQ29sdW1uU2l6ZXMoY2hpbGRyZW46IFF1ZXJ5TGlzdDxJZ3hDb2x1bW5Db21wb25lbnQ+KTogQXJyYXk8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGNvbHVtblNpemVzID0gdGhpcy5nZXRJbml0aWFsQ2hpbGRDb2x1bW5TaXplcyhjaGlsZHJlbik7XG5cbiAgICAgICAgLy8gZmlsbCB0aGUgZ2FwcyBpZiB0aGVyZSBhcmUgYW55XG4gICAgICAgIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5TaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbHVtblNpemVzW2ldICYmICEhY29sdW1uU2l6ZXNbaV0ud2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb2x1bW5TaXplc1tpXS53aWR0aCArICdweCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludCh0aGlzLmdyaWQuZ2V0UG9zc2libGVDb2x1bW5XaWR0aCgpLCAxMCkgKyAncHgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRDb2x1bW5TaXplc1N0cmluZyhjaGlsZHJlbjogUXVlcnlMaXN0PElneENvbHVtbkNvbXBvbmVudD4pOiBzdHJpbmcge1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLmdldEZpbGxlZENoaWxkQ29sdW1uU2l6ZXMoY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gcmVzLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UmVzaXphYmxlQ29sVW5kZXJFbmQoKTogTVJMUmVzaXplQ29sdW1uSW5mb1tdIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uTGF5b3V0IHx8ICF0aGlzLmNvbHVtbkxheW91dENoaWxkIHx8IHRoaXMuY29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiBbeyB0YXJnZXQ6IHRoaXMsIHNwYW5Vc2VkOiAxIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29sdW1uU2l6ZWQgPSB0aGlzLmdldEluaXRpYWxDaGlsZENvbHVtblNpemVzKHRoaXMucGFyZW50LmNoaWxkcmVuKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0czogTVJMUmVzaXplQ29sdW1uSW5mb1tdID0gW107XG4gICAgICAgIGNvbnN0IGNvbEVuZCA9IHRoaXMuY29sRW5kID8gdGhpcy5jb2xFbmQgOiB0aGlzLmNvbFN0YXJ0ICsgMTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtblNpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xTdGFydCA8PSBpICsgMSAmJiBpICsgMSA8IGNvbEVuZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldHMucHVzaCh7IHRhcmdldDogY29sdW1uU2l6ZWRbaV0ucmVmLCBzcGFuVXNlZDogMSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldHNTcXVhc2hlZDogTVJMUmVzaXplQ29sdW1uSW5mb1tdID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFyZ2V0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRhcmdldHNTcXVhc2hlZC5sZW5ndGggJiYgdGFyZ2V0c1NxdWFzaGVkW3RhcmdldHNTcXVhc2hlZC5sZW5ndGggLSAxXS50YXJnZXQuZmllbGQgPT09IHRhcmdldHNbal0udGFyZ2V0LmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0c1NxdWFzaGVkW3RhcmdldHNTcXVhc2hlZC5sZW5ndGggLSAxXS5zcGFuVXNlZCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzU3F1YXNoZWQucHVzaCh0YXJnZXRzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRzU3F1YXNoZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGlucyB0aGUgY29sdW1uIGF0IHRoZSBwcm92aWRlZCBpbmRleCBpbiB0aGUgcGlubmVkIGFyZWEuIERlZmF1bHRzIHRvIGluZGV4IGAwYCBpZiBub3QgcHJvdmlkZWQuXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbHVtbiBpcyBzdWNjZXNzZnVsbHkgcGlubmVkLiBSZXR1cm5zIGBmYWxzZWAgaWYgdGhlIGNvbHVtbiBjYW5ub3QgYmUgcGlubmVkLlxuICAgICAqIENvbHVtbiBjYW5ub3QgYmUgcGlubmVkIGlmOlxuICAgICAqIC0gSXMgYWxyZWFkeSBwaW5uZWRcbiAgICAgKiAtIGluZGV4IGFyZ3VtZW50IGlzIG91dCBvZiByYW5nZVxuICAgICAqIC0gVGhlIHBpbm5lZCBhcmVhIGV4Y2VlZHMgODAlIG9mIHRoZSBncmlkIHdpZHRoXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBzdWNjZXNzID0gdGhpcy5jb2x1bW4ucGluKCk7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBwaW4oaW5kZXg/OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgLy8gVE9ETzogUHJvYmFibHkgc2hvdWxkIHRoZSByZXR1cm4gdHlwZSBvZiB0aGUgb2xkIGZ1bmN0aW9uc1xuICAgICAgICAvLyBzaG91bGQgYmUgbW92ZWQgYXMgYSBldmVudCBwYXJhbWV0ZXIuXG4gICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5lbmRFZGl0KHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9waW5uZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiAhdGhpcy5wYXJlbnQucGlubmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3BMZXZlbFBhcmVudC5waW4oaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZ3JpZCA9ICh0aGlzLmdyaWQgYXMgYW55KTtcbiAgICAgICAgY29uc3QgaGFzSW5kZXggPSBpbmRleCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaGFzSW5kZXggJiYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBncmlkLnBpbm5lZENvbHVtbnMubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCAmJiAhdGhpcy5waW5uYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcGlubmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5waW5uZWRDaGFuZ2UuZW1pdCh0aGlzLl9waW5uZWQpO1xuICAgICAgICB0aGlzLl91bnBpbm5lZEluZGV4ID0gZ3JpZC5fdW5waW5uZWRDb2x1bW5zLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGluZGV4ID0gaW5kZXggIT09IHVuZGVmaW5lZCA/IGluZGV4IDogZ3JpZC5fcGlubmVkQ29sdW1ucy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHRhcmdldENvbHVtbiA9IGdyaWQuX3Bpbm5lZENvbHVtbnNbaW5kZXhdO1xuICAgICAgICBjb25zdCBhcmdzID0geyBjb2x1bW46IHRoaXMsIGluc2VydEF0SW5kZXg6IGluZGV4LCBpc1Bpbm5lZDogdHJ1ZSB9O1xuICAgICAgICBncmlkLm9uQ29sdW1uUGlubmluZy5lbWl0KGFyZ3MpO1xuXG4gICAgICAgIGlmIChncmlkLl9waW5uZWRDb2x1bW5zLmluZGV4T2YodGhpcykgPT09IC0xKSB7XG4gICAgICAgICAgICBncmlkLl9waW5uZWRDb2x1bW5zLnNwbGljZShhcmdzLmluc2VydEF0SW5kZXgsIDAsIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAoZ3JpZC5fdW5waW5uZWRDb2x1bW5zLmluZGV4T2YodGhpcykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5fdW5waW5uZWRDb2x1bW5zLnNwbGljZShncmlkLl91bnBpbm5lZENvbHVtbnMuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzSW5kZXgpIHtcbiAgICAgICAgICAgIGdyaWQuX21vdmVDb2x1bW5zKHRoaXMsIHRhcmdldENvbHVtbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgdGhpcy5hbGxDaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLnBpbigpKTtcbiAgICAgICAgICAgIGdyaWQucmVpbml0UGluU3RhdGVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLnJlc2V0Q2FjaGVzKCk7XG4gICAgICAgIGdyaWQubm90aWZ5Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5MYXlvdXRDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmNvbHVtbnMuZmlsdGVyKHggPT4geC5jb2x1bW5MYXlvdXQpLmZvckVhY2goeCA9PiB4LnBvcHVsYXRlVmlzaWJsZUluZGV4ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmlkLmZpbHRlcmluZ1NlcnZpY2UucmVmcmVzaEV4cHJlc3Npb25zKCk7XG4gICAgICAgIC8vIHRoaXMuZ3JpZC5yZWZyZXNoU2VhcmNoKHRydWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5waW5zIHRoZSBjb2x1bW4gYW5kIHBsYWNlIGl0IGF0IHRoZSBwcm92aWRlZCBpbmRleCBpbiB0aGUgdW5waW5uZWQgYXJlYS4gRGVmYXVsdHMgdG8gaW5kZXggYDBgIGlmIG5vdCBwcm92aWRlZC5cbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29sdW1uIGlzIHN1Y2Nlc3NmdWxseSB1bnBpbm5lZC4gUmV0dXJucyBgZmFsc2VgIGlmIHRoZSBjb2x1bW4gY2Fubm90IGJlIHVucGlubmVkLlxuICAgICAqIENvbHVtbiBjYW5ub3QgYmUgdW5waW5uZWQgaWY6XG4gICAgICogLSBJcyBhbHJlYWR5IHVucGlubmVkXG4gICAgICogLSBpbmRleCBhcmd1bWVudCBpcyBvdXQgb2YgcmFuZ2VcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHN1Y2Nlc3MgPSB0aGlzLmNvbHVtbi51bnBpbigpO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgdW5waW4oaW5kZXg/OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmVuZEVkaXQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9waW5uZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5waW5uZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcExldmVsUGFyZW50LnVucGluKGluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdyaWQgPSAodGhpcy5ncmlkIGFzIGFueSk7XG4gICAgICAgIGNvbnN0IGhhc0luZGV4ID0gaW5kZXggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGhhc0luZGV4ICYmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gZ3JpZC5fdW5waW5uZWRDb2x1bW5zLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gKGluZGV4ICE9PSB1bmRlZmluZWQgPyBpbmRleCA6XG4gICAgICAgICAgICB0aGlzLl91bnBpbm5lZEluZGV4ICE9PSB1bmRlZmluZWQgPyB0aGlzLl91bnBpbm5lZEluZGV4IDogdGhpcy5pbmRleCk7XG4gICAgICAgIHRoaXMuX3Bpbm5lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBpbm5lZENoYW5nZS5lbWl0KHRoaXMuX3Bpbm5lZCk7XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uID0gZ3JpZC5fdW5waW5uZWRDb2x1bW5zW2luZGV4XTtcblxuICAgICAgICBncmlkLl91bnBpbm5lZENvbHVtbnMuc3BsaWNlKGluZGV4LCAwLCB0aGlzKTtcbiAgICAgICAgaWYgKGdyaWQuX3Bpbm5lZENvbHVtbnMuaW5kZXhPZih0aGlzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGdyaWQuX3Bpbm5lZENvbHVtbnMuc3BsaWNlKGdyaWQuX3Bpbm5lZENvbHVtbnMuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzSW5kZXgpIHtcbiAgICAgICAgICAgIGdyaWQuX21vdmVDb2x1bW5zKHRoaXMsIHRhcmdldENvbHVtbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgdGhpcy5hbGxDaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLnVucGluKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZWluaXRQaW5TdGF0ZXMoKTtcbiAgICAgICAgZ3JpZC5yZXNldENhY2hlcygpO1xuXG4gICAgICAgIGNvbnN0IGluc2VydEF0SW5kZXggPSBncmlkLl91bnBpbm5lZENvbHVtbnMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHsgY29sdW1uOiB0aGlzLCBpbnNlcnRBdEluZGV4LCBpc1Bpbm5lZDogZmFsc2UgfTtcbiAgICAgICAgZ3JpZC5vbkNvbHVtblBpbm5pbmcuZW1pdChhcmdzKTtcblxuICAgICAgICBncmlkLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uTGF5b3V0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5jb2x1bW5zLmZpbHRlcih4ID0+IHguY29sdW1uTGF5b3V0KS5mb3JFYWNoKHggPT4geC5wb3B1bGF0ZVZpc2libGVJbmRleGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JpZC5maWx0ZXJpbmdTZXJ2aWNlLnJlZnJlc2hFeHByZXNzaW9ucygpO1xuICAgICAgICAvLyB0aGlzLmdyaWQucmVmcmVzaFNlYXJjaCh0cnVlKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgdG9wIGxldmVsIHBhcmVudCBjb2x1bW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCB0b3BMZXZlbFBhcmVudCA9ICB0aGlzLmNvbHVtbi50b3BMZXZlbFBhcmVudDtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IHRvcExldmVsUGFyZW50KCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGhlYWRlciBvZiB0aGUgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4gICAgICogbGV0IGhlYWRlckNlbGwgPSBjb2x1bW4uaGVhZGVyQ2VsbDtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGhlYWRlckNlbGwoKTogSWd4R3JpZEhlYWRlckNvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuaGVhZGVyQ2VsbExpc3QuZmluZCgoaGVhZGVyKSA9PiBoZWFkZXIuY29sdW1uID09PSB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGZpbHRlciBjZWxsIG9mIHRoZSBjb2x1bW4uXG4gICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4gICAgKiBsZXQgZmlsdGVyZWxsID0gY29sdW1uLmZpbHRlcmVsbDtcbiAgICAqIGBgYFxuICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICovXG4gICAgZ2V0IGZpbHRlckNlbGwoKTogSWd4R3JpZEZpbHRlcmluZ0NlbGxDb21wb25lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmZpbHRlckNlbGxMaXN0LmZpbmQoKGZpbHRlckNlbGwpID0+IGZpbHRlckNlbGwuY29sdW1uID09PSB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBoZWFkZXIgZ3JvdXAgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGhlYWRlckdyb3VwKCk6IElneEdyaWRIZWFkZXJHcm91cENvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuaGVhZGVyR3JvdXBzTGlzdC5maW5kKChoZWFkZXJHcm91cCkgPT4gaGVhZGVyR3JvdXAuY29sdW1uID09PSB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdXRvc2l6ZSB0aGUgY29sdW1uIHRvIHRoZSBsb25nZXN0IGN1cnJlbnRseSB2aXNpYmxlIGNlbGwgdmFsdWUsIGluY2x1ZGluZyB0aGUgaGVhZGVyIGNlbGwuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoJ2dyaWQnKSBncmlkOiBJZ3hHcmlkQ29tcG9uZW50O1xuICAgICAqIGxldCBjb2x1bW4gPSB0aGlzLmdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLmZpZWxkID09PSAnSUQnKVswXTtcbiAgICAgKiBjb2x1bW4uYXV0b3NpemUoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGF1dG9zaXplKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29sdW1uR3JvdXApIHtcblxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuZ2V0TGFyZ2VzdENlbGxXaWR0aCgpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLnJlZmxvdygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDYWxjV2lkdGgoKTogYW55IHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbGNXaWR0aCAhPT0gbnVsbCAmJiAhaXNOYU4odGhpcy5jYWxjUGl4ZWxXaWR0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxjV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZUNhbGNXaWR0aCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY1dpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIChpbiBwaXhlbHMpIG9mIHRoZSBsb25nZXN0IGN1cnJlbnRseSB2aXNpYmxlIGNlbGwsIGluY2x1ZGluZyB0aGUgaGVhZGVyIGNlbGwuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoJ2dyaWQnKSBncmlkOiBJZ3hHcmlkQ29tcG9uZW50O1xuICAgICAqXG4gICAgICogbGV0IGNvbHVtbiA9IHRoaXMuZ3JpZC5jb2x1bW5MaXN0LmZpbHRlcihjID0+IGMuZmllbGQgPT09ICdJRCcpWzBdO1xuICAgICAqIGxldCBzaXplID0gY29sdW1uLmdldExhcmdlc3RDZWxsV2lkdGgoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldExhcmdlc3RDZWxsV2lkdGgoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLmdyaWQuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgY29uc3QgbGFyZ2VzdCA9IG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY2VsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGNlbGxzQ29udGVudFdpZHRocyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2VsbHNbMF0ubmF0aXZlRWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jZWxscy5mb3JFYWNoKChjZWxsKSA9PiBjZWxsc0NvbnRlbnRXaWR0aHMucHVzaChjZWxsLmNhbGN1bGF0ZVNpemVUb0ZpdChyYW5nZSkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbHNDb250ZW50V2lkdGhzID0gdGhpcy5jZWxscy5tYXAoKGNlbGwpID0+IGdldE5vZGVTaXplVmlhUmFuZ2UocmFuZ2UsIGNlbGwubmF0aXZlRWxlbWVudCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNlbGxzQ29udGVudFdpZHRocy5pbmRleE9mKE1hdGgubWF4KC4uLmNlbGxzQ29udGVudFdpZHRocykpO1xuICAgICAgICAgICAgY29uc3QgY2VsbFN0eWxlID0gdGhpcy5ncmlkLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5jZWxsc1tpbmRleF0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBjZWxsUGFkZGluZyA9IHBhcnNlRmxvYXQoY2VsbFN0eWxlLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQoY2VsbFN0eWxlLnBhZGRpbmdSaWdodCkgK1xuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoY2VsbFN0eWxlLmJvcmRlclJpZ2h0V2lkdGgpO1xuXG4gICAgICAgICAgICBsYXJnZXN0LnNldChNYXRoLm1heCguLi5jZWxsc0NvbnRlbnRXaWR0aHMpLCBjZWxsUGFkZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oZWFkZXJDZWxsKSB7XG4gICAgICAgICAgICBsZXQgaGVhZGVyQ2VsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWRlclRlbXBsYXRlICYmIHRoaXMuaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0uY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGhlYWRlckNlbGwgPSBNYXRoLm1heCguLi5BcnJheS5mcm9tKHRoaXMuaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0uY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGNoaWxkKSA9PiBnZXROb2RlU2l6ZVZpYVJhbmdlKHJhbmdlLCBjaGlsZCkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyQ2VsbCA9IGdldE5vZGVTaXplVmlhUmFuZ2UocmFuZ2UsIHRoaXMuaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zb3J0YWJsZSB8fCB0aGlzLmZpbHRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJDZWxsICs9IHRoaXMuaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclN0eWxlID0gdGhpcy5ncmlkLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYWRkaW5nID0gcGFyc2VGbG9hdChoZWFkZXJTdHlsZS5wYWRkaW5nTGVmdCkgKyBwYXJzZUZsb2F0KGhlYWRlclN0eWxlLnBhZGRpbmdSaWdodCkgK1xuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaGVhZGVyU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCk7XG4gICAgICAgICAgICBsYXJnZXN0LnNldChoZWFkZXJDZWxsLCBoZWFkZXJQYWRkaW5nKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGFyZ2VzdENlbGwgPSBNYXRoLm1heCguLi5BcnJheS5mcm9tKGxhcmdlc3Qua2V5cygpKSk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKGxhcmdlc3RDZWxsICsgbGFyZ2VzdC5nZXQobGFyZ2VzdENlbGwpKTtcblxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHdpZHRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggKyAncHgnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldENlbGxXaWR0aCgpIHtcbiAgICAgICAgY29uc3QgY29sV2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IGNvbFdpZHRoICYmIHR5cGVvZiBjb2xXaWR0aCA9PT0gJ3N0cmluZycgJiYgY29sV2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcblxuICAgICAgICBpZiAodGhpcy5jb2x1bW5MYXlvdXRDaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbFdpZHRoICYmICFpc1BlcmNlbnRhZ2VXaWR0aCkge1xuXG4gICAgICAgICAgICBsZXQgY2VsbFdpZHRoID0gY29sV2lkdGg7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNlbGxXaWR0aCAhPT0gJ3N0cmluZycgfHwgY2VsbFdpZHRoLmVuZHNXaXRoKCdweCcpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNlbGxXaWR0aCArPSAncHgnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2VsbFdpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbFdpZHRoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjYWNoZUNhbGNXaWR0aCgpOiBhbnkge1xuICAgICAgICBjb25zdCBncmlkID0gdGhpcy5ncmlkQVBJLmdyaWQ7XG4gICAgICAgIGNvbnN0IGNvbFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgY29uc3QgaXNQZXJjZW50YWdlV2lkdGggPSBjb2xXaWR0aCAmJiB0eXBlb2YgY29sV2lkdGggPT09ICdzdHJpbmcnICYmIGNvbFdpZHRoLmluZGV4T2YoJyUnKSAhPT0gLTE7XG4gICAgICAgIGlmIChpc1BlcmNlbnRhZ2VXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5fY2FsY1dpZHRoID0gcGFyc2VJbnQoY29sV2lkdGgsIDEwKSAvIDEwMCAqIChncmlkLmNhbGNXaWR0aCAtIGdyaWQuZmVhdHVyZUNvbHVtbnNXaWR0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbFdpZHRoKSB7XG4gICAgICAgICAgICAvLyBubyB3aWR0aFxuICAgICAgICAgICAgdGhpcy5fY2FsY1dpZHRoID0gdGhpcy5kZWZhdWx0V2lkdGggfHwgZ3JpZC5nZXRQb3NzaWJsZUNvbHVtbldpZHRoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjV2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsY1BpeGVsV2lkdGggPSBwYXJzZUludCh0aGlzLl9jYWxjV2lkdGgsIDEwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAqL1xuICAgIHB1YmxpYyBnZXQgcGlubmFibGUoKSB7XG4gICAgICAgIGNvbnN0IGdyaWRVbnBpbm5lZFdpZHRoID0gKHRoaXMuZ3JpZCBhcyBhbnkpLmdldFVucGlubmVkV2lkdGgodHJ1ZSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRXaWR0aCA9IHRoaXMucGFyZW50ID8gcGFyc2VJbnQodGhpcy50b3BMZXZlbFBhcmVudC53aWR0aCwgMTApIDogcGFyc2VJbnQodGhpcy53aWR0aCwgMTApO1xuICAgICAgICByZXR1cm4gKHRoaXMuZ3JpZCBhcyBhbnkpLl9pbml0IHx8ICEoKGdyaWRVbnBpbm5lZFdpZHRoIC0gZWxlbWVudFdpZHRoKSA8IHRoaXMuZ3JpZC51bnBpbm5lZEFyZWFNaW5XaWR0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBwb3B1bGF0ZVZpc2libGVJbmRleGVzKCkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG59XG5cblxuQENvbXBvbmVudCh7XG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBJZ3hDb2x1bW5Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElneENvbHVtbkdyb3VwQ29tcG9uZW50KSB9XSxcbiAgICBzZWxlY3RvcjogJ2lneC1jb2x1bW4tZ3JvdXAnLFxuICAgIHRlbXBsYXRlOiBgYFxufSlcbmV4cG9ydCBjbGFzcyBJZ3hDb2x1bW5Hcm91cENvbXBvbmVudCBleHRlbmRzIElneENvbHVtbkNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gICAgQENvbnRlbnRDaGlsZHJlbihJZ3hDb2x1bW5Db21wb25lbnQsIHsgcmVhZDogSWd4Q29sdW1uQ29tcG9uZW50IH0pXG4gICAgY2hpbGRyZW4gPSBuZXcgUXVlcnlMaXN0PElneENvbHVtbkNvbXBvbmVudD4oKTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gZ3JvdXAgYHN1bW1hcmllc2AuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5Hcm91cFN1bW1hcmllcyA9IHRoaXMuY29sdW1uR3JvdXAuc3VtbWFyaWVzO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Hcm91cENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBzdW1tYXJpZXMoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1bW1hcmllcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29sdW1uIGdyb3VwIGBzdW1tYXJpZXNgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbkdyb3VwLnN1bW1hcmllcyA9IElneE51bWJlclN1bW1hcnlPcGVyYW5kO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Hcm91cENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgc3VtbWFyaWVzKGNsYXNzUmVmOiBhbnkpIHsgfVxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gZ3JvdXAgaXMgYHNlYXJjaGFibGVgLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYHRydWVgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNTZWFyY2hhYmxlID0gIHRoaXMuY29sdW1uR3JvdXAuc2VhcmNoYWJsZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogIDxpZ3gtY29sdW1uLWdyb3VwIFtzZWFyY2hhYmxlXSA9IFwiZmFsc2VcIj48L2lneC1jb2x1bW4tZ3JvdXA+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkdyb3VwQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2VhcmNoYWJsZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29sdW1uIGdyb3VwIGBmaWx0ZXJzYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkdyb3VwRmlsdGVycyA9IHRoaXMuY29sdW1uR3JvdXAuZmlsdGVycztcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uR3JvdXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgZmlsdGVycygpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29sdW1uIGdyb3VwIGBmaWx0ZXJzYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5jb2x1bW5Hcm91cC5maWx0ZXJzID0gSWd4U3RyaW5nRmlsdGVyaW5nT3BlcmFuZDtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uR3JvdXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGZpbHRlcnMoY2xhc3NSZWY6IGFueSkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBib2R5IHRlbXBsYXRlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgYm9keVRlbXBsYXRlID0gdGhpcy5jb2x1bW5Hcm91cC5ib2R5VGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkdyb3VwQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGJvZHlUZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHlUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCBib2R5VGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pIHsgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgaW5saW5lIGVkaXRvciB0ZW1wbGF0ZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlubGluZUVkaXRvclRlbXBsYXRlID0gdGhpcy5jb2x1bW5Hcm91cC5pbmxpbmVFZGl0b3JUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uR3JvdXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgaW5saW5lRWRpdG9yVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmxpbmVFZGl0b3JUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCBpbmxpbmVFZGl0b3JUZW1wbGF0ZSh0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PikgeyB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29sdW1uIGdyb3VwIGNlbGxzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uQ2VsbHMgPSB0aGlzLmNvbHVtbkdyb3VwLmNlbGxzO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Hcm91cENvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBjZWxscygpOiBJZ3hHcmlkQ2VsbENvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBncm91cCBpcyBoaWRkZW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc0hpZGRlbiA9IHRoaXMuY29sdW1uR3JvdXAuaGlkZGVuO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Hcm91cENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGhpZGRlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsQ2hpbGRyZW4uZXZlcnkoYyA9PiBjLmhpZGRlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbHVtbiBncm91cCBoaWRkZW4gcHJvcGVydHkuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtoaWRkZW5dID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVHdvLXdheSBkYXRhIGJpbmRpbmdcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gWyhoaWRkZW4pXSA9IFwibW9kZWwuY29sdW1uc1swXS5pc0hpZGRlblwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uR3JvdXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgaGlkZGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2hpZGRlbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhpZGRlbkNoYW5nZS5lbWl0KHRoaXMuX2hpZGRlbik7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC5oaWRkZW4gPSB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGhpZGRlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgIEBDb250ZW50Q2hpbGRyZW4gd2l0aCBkZXNjZW5kYW50cyBzdGlsbCByZXR1cm5zIHRoZSBgcGFyZW50YFxuICAgICAgICAgICAgY29tcG9uZW50IGluIHRoZSBxdWVyeSBsaXN0LlxuICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5oZWFkVGVtcGxhdGUgJiYgdGhpcy5oZWFkVGVtcGxhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJUZW1wbGF0ZSA9IHRoaXMuaGVhZFRlbXBsYXRlLnRvQXJyYXkoKVswXS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuLnJlc2V0KHRoaXMuY2hpbGRyZW4udG9BcnJheSgpLnNsaWNlKDEpKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIH0pO1xuICAgICAgICAvKlxuICAgICAgICAgICAgVE8gRE86IEluIEFuZ3VsYXIgOSB0aGlzIG5lZWQgdG8gYmUgcmVtb3ZlZCwgYmVjYXVzZSB0aGUgQENvbnRlbnRDaGlsZHJlbiB3aWxsIG5vdCByZXR1cm4gdGhlIGBwYXJlbnRgXG4gICAgICAgICAgICBjb21wb25lbnQgaW4gdGhlIHF1ZXJ5IGxpc3QuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uY2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UuZmlyc3QgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5yZXNldCh0aGlzLmNoaWxkcmVuLnRvQXJyYXkoKS5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjaGlsZHJlbiBjb2x1bW5zIGNvbGxlY3Rpb24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5zID0gIHRoaXMuY29sdW1uR3JvdXAuYWxsQ2hpbGRyZW47XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkdyb3VwQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGFsbENoaWxkcmVuKCk6IElneENvbHVtbkNvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW4odGhpcy5jaGlsZHJlbi50b0FycmF5KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBjb2x1bW4gaXMgYSBgQ29sdW1uR3JvdXBgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNDb2x1bW5Hcm91cCA9ICB0aGlzLmNvbHVtbkdyb3VwLmNvbHVtbkdyb3VwXG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkdyb3VwQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGNvbHVtbkdyb3VwKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgY29sdW1uIGlzIGEgYENvbHVtbkxheW91dGAgZm9yIG11bHRpLXJvdyBsYXlvdXQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5Hcm91cCA9ICB0aGlzLmNvbHVtbi5jb2x1bW5Hcm91cDtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGNvbHVtbkxheW91dCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB3aWR0aCBvZiB0aGUgY29sdW1uIGdyb3VwLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uR3JvdXBXaWR0aCA9IHRoaXMuY29sdW1uR3JvdXAud2lkdGg7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkdyb3VwQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICBsZXQgaXNDaGlsZHJlbldpZHRoSW5QZXJjZW50ID0gZmFsc2UsIHdpZHRoO1xuICAgICAgICB3aWR0aCA9IGAke3RoaXMuY2hpbGRyZW4ucmVkdWNlKChhY2MsIHZhbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbC5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwud2lkdGggPT09ICdzdHJpbmcnICYmIHZhbC53aWR0aC5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaXNDaGlsZHJlbldpZHRoSW5QZXJjZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2MgKyBwYXJzZUludCh2YWwud2lkdGgsIDEwKTtcbiAgICAgICAgfSwgMCl9YDtcbiAgICAgICAgcmV0dXJuIGlzQ2hpbGRyZW5XaWR0aEluUGVyY2VudCA/IHdpZHRoICsgJyUnIDogd2lkdGg7XG4gICAgfVxuXG4gICAgc2V0IHdpZHRoKHZhbCkgeyB9XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZ3JpZEFQSTogR3JpZEJhc2VBUElTZXJ2aWNlPElneEdyaWRCYXNlQ29tcG9uZW50ICYgSUdyaWREYXRhQmluZGFibGU+LCBwdWJsaWMgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHVibGljIHJvd0lzbGFuZEFQSTogSWd4Um93SXNsYW5kQVBJU2VydmljZSkge1xuICAgICAgICAvLyBELlAuIGNvbnN0cnVjdG9yIGR1cGxpY2F0aW9uIGR1ZSB0byBlczYgY29tcGlsYXRpb24sIG1pZ2h0IGJlIG9ic29sZXRlIGluIHRoZSBmdXR1cmVcbiAgICAgICAgc3VwZXIoZ3JpZEFQSSwgY2RyLCByb3dJc2xhbmRBUEkpO1xuICAgIH1cbn1cblxuQENvbXBvbmVudCh7XG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBJZ3hDb2x1bW5Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElneENvbHVtbkxheW91dENvbXBvbmVudCkgfV0sXG4gICAgc2VsZWN0b3I6ICdpZ3gtY29sdW1uLWxheW91dCcsXG4gICAgdGVtcGxhdGU6IGBgXG59KVxuZXhwb3J0IGNsYXNzIElneENvbHVtbkxheW91dENvbXBvbmVudCBleHRlbmRzIElneENvbHVtbkdyb3VwQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcbiAgICBwdWJsaWMgY2hpbGRyZW5WaXNpYmxlSW5kZXhlcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gbGF5b3V0LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uR3JvdXBXaWR0aCA9IHRoaXMuY29sdW1uR3JvdXAud2lkdGg7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkdyb3VwQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCk6IGFueSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRGaWxsZWRDaGlsZENvbHVtblNpemVzKHRoaXMuY2hpbGRyZW4pLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHBhcnNlSW50KHZhbCwgMTApLCAwKTtcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH1cblxuICAgIHNldCB3aWR0aCh2YWw6IGFueSkgeyB9XG5cbiAgICBnZXQgY29sdW1uTGF5b3V0KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldENhbGNXaWR0aCgpOiBhbnkge1xuICAgICAgICBsZXQgYm9yZGVyV2lkdGggPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmhlYWRlckdyb3VwICYmIHRoaXMuaGVhZGVyR3JvdXAuaGFzTGFzdFBpbm5lZENoaWxkQ29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJTdHlsZXMgPSB0aGlzLmdyaWQuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmhlYWRlckdyb3VwLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXSk7XG4gICAgICAgICAgICBib3JkZXJXaWR0aCA9IHBhcnNlSW50KGhlYWRlclN0eWxlcy5ib3JkZXJSaWdodFdpZHRoLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0Q2FsY1dpZHRoKCkgKyBib3JkZXJXaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb2x1bW4gdmlzaWJsZSBpbmRleC5cbiAgICAgKiBJZiB0aGUgY29sdW1uIGlzIG5vdCB2aXNpYmxlLCByZXR1cm5zIGAtMWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCB2aXNpYmxlQ29sdW1uSW5kZXggPSAgdGhpcy5jb2x1bW4udmlzaWJsZUluZGV4O1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgdmlzaWJsZUluZGV4KCk6IG51bWJlciB7XG4gICAgICAgIGlmICghaXNOYU4odGhpcy5fdkluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVucGlubmVkQ29sdW1ucyA9IHRoaXMuZ3JpZC51bnBpbm5lZENvbHVtbnMuZmlsdGVyKGMgPT4gYy5jb2x1bW5MYXlvdXQgJiYgIWMuaGlkZGVuKTtcbiAgICAgICAgY29uc3QgcGlubmVkQ29sdW1ucyA9IHRoaXMuZ3JpZC5waW5uZWRDb2x1bW5zLmZpbHRlcihjID0+IGMuY29sdW1uTGF5b3V0ICYmICFjLmhpZGRlbik7XG4gICAgICAgIGxldCB2SW5kZXggPSAtMTtcblxuICAgICAgICBpZiAoIXRoaXMucGlubmVkKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleEluQ29sbGVjdGlvbiA9IHVucGlubmVkQ29sdW1ucy5pbmRleE9mKHRoaXMpO1xuICAgICAgICAgICAgdkluZGV4ID0gaW5kZXhJbkNvbGxlY3Rpb24gPT09IC0xID8gLTEgOiBwaW5uZWRDb2x1bW5zLmxlbmd0aCArIGluZGV4SW5Db2xsZWN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdkluZGV4ID0gcGlubmVkQ29sdW1ucy5pbmRleE9mKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZJbmRleCA9IHZJbmRleDtcbiAgICAgICAgcmV0dXJuIHZJbmRleDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgY29sdW1uIGxheW91dCBpcyBoaWRkZW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc0hpZGRlbiA9IHRoaXMuY29sdW1uR3JvdXAuaGlkZGVuO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Hcm91cENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGhpZGRlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZGRlbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2x1bW4gbGF5b3V0IGhpZGRlbiBwcm9wZXJ0eS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogPGlneC1jb2x1bW4tbGF5b3V0IFtoaWRkZW5dID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uLT5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uR3JvdXBDb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgaGlkZGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2hpZGRlbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQuaGlkZGVuID0gdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5ncmlkICYmIHRoaXMuZ3JpZC5jb2x1bW5zICYmIHRoaXMuZ3JpZC5jb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IGluZGV4ZXMgaW4gY2FzZSBjb2x1bW5zIGFyZSBoaWRkZW4vc2hvd24gcnVudGltZVxuICAgICAgICAgICAgdGhpcy5ncmlkLmNvbHVtbnMuZmlsdGVyKHggPT4geC5jb2x1bW5Hcm91cCkuZm9yRWFjaCh4ID0+IHgucG9wdWxhdGVWaXNpYmxlSW5kZXhlcygpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICovXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICBzdXBlci5uZ0FmdGVyQ29udGVudEluaXQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmhpZGRlbikge1xuICAgICAgICAgICAgdGhpcy5oaWRkZW4gPSB0aGlzLmFsbENoaWxkcmVuLnNvbWUoeCA9PiB4LmhpZGRlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQuaGlkZGVuID0gdGhpcy5oaWRkZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGNoaWxkLm1vdmFibGUgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGdyb3VwIGNvbnRhaW5zIHRoZSBsYXN0IHBpbm5lZCBjaGlsZCBjb2x1bW4gb2YgdGhlIGNvbHVtbiBsYXlvdXQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bXNIYXNMYXN0UGlubmVkID0gdGhpcy5jb2x1bW5MYXlvdXQuaGFzTGFzdFBpbm5lZENoaWxkQ29sdW1uO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5MYXlvdXRDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgaGFzTGFzdFBpbm5lZENoaWxkQ29sdW1uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5zb21lKGNoaWxkID0+IGNoaWxkLmlzTGFzdFBpbm5lZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgKi9cbiAgICBwdWJsaWMgcG9wdWxhdGVWaXNpYmxlSW5kZXhlcygpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlblZpc2libGVJbmRleGVzID0gW107XG4gICAgICAgIGNvbnN0IGdyaWQgPSB0aGlzLmdyaWRBUEkuZ3JpZDtcbiAgICAgICAgY29uc3QgY29sdW1ucyA9IGdyaWQgJiYgZ3JpZC5waW5uZWRDb2x1bW5zICYmIGdyaWQudW5waW5uZWRDb2x1bW5zID8gZ3JpZC5waW5uZWRDb2x1bW5zLmNvbmNhdChncmlkLnVucGlubmVkQ29sdW1ucykgOiBbXTtcbiAgICAgICAgY29uc3Qgb3JkZXJlZENvbHMgPSBjb2x1bW5zXG4gICAgICAgICAgICAuZmlsdGVyKHggPT4gIXguY29sdW1uR3JvdXAgJiYgIXguaGlkZGVuKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEucm93U3RhcnQgLSBiLnJvd1N0YXJ0IHx8IGNvbHVtbnMuaW5kZXhPZihhLnBhcmVudCkgLSBjb2x1bW5zLmluZGV4T2YoYi5wYXJlbnQpIHx8IGEuY29sU3RhcnQgLSBiLmNvbFN0YXJ0KTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJzID0gY2hpbGQucm93U3RhcnQgfHwgMTtcbiAgICAgICAgICAgIGxldCB2SW5kZXggPSAwO1xuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBhbGwgY29scyB3aXRoIGxhcmdlciByb3dTdGFydFxuICAgICAgICAgICAgY29uc3QgY29scyA9IG9yZGVyZWRDb2xzLmZpbHRlcihjID0+XG4gICAgICAgICAgICAgICAgIWMuY29sdW1uR3JvdXAgJiYgKGMucm93U3RhcnQgfHwgMSkgPD0gcnMpO1xuICAgICAgICAgICAgdkluZGV4ID0gY29scy5pbmRleE9mKGNoaWxkKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5WaXNpYmxlSW5kZXhlcy5wdXNoKHsgY29sdW1uOiBjaGlsZCwgaW5kZXg6IHZJbmRleCB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19